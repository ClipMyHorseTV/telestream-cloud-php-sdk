<?php
/**
 * Factory
 *
 * PHP version 5
 *
 * @category Class
 * @package  TelestreamCloud
 * @author   Swaagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Flip API
 *
 * Description
 *
 * OpenAPI spec version: 3.1.0
 * Contact: cloudsupport@telestream.net
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace TelestreamCloud\Flip;

use \ArrayAccess;

/**
 * Factory Class Doc Comment
 *
 * @category    Class
 * @package     TelestreamCloud
 * @author      Swagger Codegen team
 * @link        https://github.com/swagger-api/swagger-codegen
 */
class Factory implements ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      * @var string
      */
    protected static $swaggerModelName = 'Factory';

    /**
      * Array of property to type mappings. Used for (de)serialization
      * @var string[]
      */
    protected static $swaggerTypes = [
        'id' => 'string',
        'name' => 'string',
        'factory_region' => 'string',
        'output_bucket_name' => 'string',
        'acl' => 'string',
        'created_at' => 'string',
        'updated_at' => 'string',
        'url' => 'string',
        'server_side_encryption' => 'bool',
        'input_bucket_name' => 'string',
        'input_bucket_watch' => 'bool',
        'input_bucket_files_map' => 'string',
        'input_bucket_sync_every_n_min' => 'string',
        'input_bucket_recursive' => 'string',
        'input_bucket_file_pattern' => 'string',
        'outputs_path_format' => 'string',
        'storage_provider' => 'int',
        'provider_specific_settings' => 'object'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      * @var string[]
      */
    protected static $swaggerFormats = [
        'id' => null,
        'name' => null,
        'factory_region' => null,
        'output_bucket_name' => null,
        'acl' => null,
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        'url' => null,
        'server_side_encryption' => null,
        'input_bucket_name' => null,
        'input_bucket_watch' => null,
        'input_bucket_files_map' => null,
        'input_bucket_sync_every_n_min' => null,
        'input_bucket_recursive' => null,
        'input_bucket_file_pattern' => null,
        'outputs_path_format' => null,
        'storage_provider' => null,
        'provider_specific_settings' => null
    ];

    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name, and the value is the original name
     * @var string[]
     */
    protected static $attributeMap = [
        'id' => 'id',
        'name' => 'name',
        'factory_region' => 'factory_region',
        'output_bucket_name' => 'output_bucket_name',
        'acl' => 'acl',
        'created_at' => 'created_at',
        'updated_at' => 'updated_at',
        'url' => 'url',
        'server_side_encryption' => 'server_side_encryption',
        'input_bucket_name' => 'input_bucket_name',
        'input_bucket_watch' => 'input_bucket_watch',
        'input_bucket_files_map' => 'input_bucket_files_map',
        'input_bucket_sync_every_n_min' => 'input_bucket_sync_every_n_min',
        'input_bucket_recursive' => 'input_bucket_recursive',
        'input_bucket_file_pattern' => 'input_bucket_file_pattern',
        'outputs_path_format' => 'outputs_path_format',
        'storage_provider' => 'storage_provider',
        'provider_specific_settings' => 'provider_specific_settings'
    ];


    /**
     * Array of attributes to setter functions (for deserialization of responses)
     * @var string[]
     */
    protected static $setters = [
        'id' => 'setId',
        'name' => 'setName',
        'factory_region' => 'setFactoryRegion',
        'output_bucket_name' => 'setOutputBucketName',
        'acl' => 'setAcl',
        'created_at' => 'setCreatedAt',
        'updated_at' => 'setUpdatedAt',
        'url' => 'setUrl',
        'server_side_encryption' => 'setServerSideEncryption',
        'input_bucket_name' => 'setInputBucketName',
        'input_bucket_watch' => 'setInputBucketWatch',
        'input_bucket_files_map' => 'setInputBucketFilesMap',
        'input_bucket_sync_every_n_min' => 'setInputBucketSyncEveryNMin',
        'input_bucket_recursive' => 'setInputBucketRecursive',
        'input_bucket_file_pattern' => 'setInputBucketFilePattern',
        'outputs_path_format' => 'setOutputsPathFormat',
        'storage_provider' => 'setStorageProvider',
        'provider_specific_settings' => 'setProviderSpecificSettings'
    ];


    /**
     * Array of attributes to getter functions (for serialization of requests)
     * @var string[]
     */
    protected static $getters = [
        'id' => 'getId',
        'name' => 'getName',
        'factory_region' => 'getFactoryRegion',
        'output_bucket_name' => 'getOutputBucketName',
        'acl' => 'getAcl',
        'created_at' => 'getCreatedAt',
        'updated_at' => 'getUpdatedAt',
        'url' => 'getUrl',
        'server_side_encryption' => 'getServerSideEncryption',
        'input_bucket_name' => 'getInputBucketName',
        'input_bucket_watch' => 'getInputBucketWatch',
        'input_bucket_files_map' => 'getInputBucketFilesMap',
        'input_bucket_sync_every_n_min' => 'getInputBucketSyncEveryNMin',
        'input_bucket_recursive' => 'getInputBucketRecursive',
        'input_bucket_file_pattern' => 'getInputBucketFilePattern',
        'outputs_path_format' => 'getOutputsPathFormat',
        'storage_provider' => 'getStorageProvider',
        'provider_specific_settings' => 'getProviderSpecificSettings'
    ];

    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    public static function setters()
    {
        return self::$setters;
    }

    public static function getters()
    {
        return self::$getters;
    }

    const ACL__PUBLIC = 'public';
    const ACL__PRIVATE = 'private';
    

    
    /**
     * Gets allowable values of the enum
     * @return string[]
     */
    public function getAclAllowableValues()
    {
        return [
            self::ACL__PUBLIC,
            self::ACL__PRIVATE,
        ];
    }
    

    /**
     * Associative array for storing property values
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     * @param mixed[] $data Associated array of property values initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['id'] = isset($data['id']) ? $data['id'] : null;
        $this->container['name'] = isset($data['name']) ? $data['name'] : null;
        $this->container['factory_region'] = isset($data['factory_region']) ? $data['factory_region'] : null;
        $this->container['output_bucket_name'] = isset($data['output_bucket_name']) ? $data['output_bucket_name'] : null;
        $this->container['acl'] = isset($data['acl']) ? $data['acl'] : null;
        $this->container['created_at'] = isset($data['created_at']) ? $data['created_at'] : null;
        $this->container['updated_at'] = isset($data['updated_at']) ? $data['updated_at'] : null;
        $this->container['url'] = isset($data['url']) ? $data['url'] : null;
        $this->container['server_side_encryption'] = isset($data['server_side_encryption']) ? $data['server_side_encryption'] : null;
        $this->container['input_bucket_name'] = isset($data['input_bucket_name']) ? $data['input_bucket_name'] : null;
        $this->container['input_bucket_watch'] = isset($data['input_bucket_watch']) ? $data['input_bucket_watch'] : null;
        $this->container['input_bucket_files_map'] = isset($data['input_bucket_files_map']) ? $data['input_bucket_files_map'] : null;
        $this->container['input_bucket_sync_every_n_min'] = isset($data['input_bucket_sync_every_n_min']) ? $data['input_bucket_sync_every_n_min'] : null;
        $this->container['input_bucket_recursive'] = isset($data['input_bucket_recursive']) ? $data['input_bucket_recursive'] : null;
        $this->container['input_bucket_file_pattern'] = isset($data['input_bucket_file_pattern']) ? $data['input_bucket_file_pattern'] : null;
        $this->container['outputs_path_format'] = isset($data['outputs_path_format']) ? $data['outputs_path_format'] : null;
        $this->container['storage_provider'] = isset($data['storage_provider']) ? $data['storage_provider'] : null;
        $this->container['provider_specific_settings'] = isset($data['provider_specific_settings']) ? $data['provider_specific_settings'] : null;
    }

    /**
     * show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalid_properties = [];

        $allowed_values = $this->getAclAllowableValues();
        if (!in_array($this->container['acl'], $allowed_values)) {
            $invalid_properties[] = sprintf(
                "invalid value for 'acl', must be one of '%s'",
                implode("', '", $allowed_values)
            );
        }

        return $invalid_properties;
    }

    /**
     * validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {

        $allowed_values = $this->getAclAllowableValues();
        if (!in_array($this->container['acl'], $allowed_values)) {
            return false;
        }
        return true;
    }


    /**
     * Gets id
     * @return string
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     * @param string $id A unique identifier of a Factory.
     * @return $this
     */
    public function setId($id)
    {
        $this->container['id'] = $id;

        return $this;
    }

    /**
     * Gets name
     * @return string
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     * @param string $name Human-readable identifier of a Factory.
     * @return $this
     */
    public function setName($name)
    {
        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets factory_region
     * @return string
     */
    public function getFactoryRegion()
    {
        return $this->container['factory_region'];
    }

    /**
     * Sets factory_region
     * @param string $factory_region A region where the factory is located.
     * @return $this
     */
    public function setFactoryRegion($factory_region)
    {
        $this->container['factory_region'] = $factory_region;

        return $this;
    }

    /**
     * Gets output_bucket_name
     * @return string
     */
    public function getOutputBucketName()
    {
        return $this->container['output_bucket_name'];
    }

    /**
     * Sets output_bucket_name
     * @param string $output_bucket_name A bucket where processed files will be stored.
     * @return $this
     */
    public function setOutputBucketName($output_bucket_name)
    {
        $this->container['output_bucket_name'] = $output_bucket_name;

        return $this;
    }

    /**
     * Gets acl
     * @return string
     */
    public function getAcl()
    {
        return $this->container['acl'];
    }

    /**
     * Sets acl
     * @param string $acl Specify if your files are public or private (private files need authorization url to access). By default this is not set.
     * @return $this
     */
    public function setAcl($acl)
    {
        $allowed_values = $this->getAclAllowableValues();
        if (!is_null($acl) && !in_array($acl, $allowed_values)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'acl', must be one of '%s'",
                    implode("', '", $allowed_values)
                )
            );
        }
        $this->container['acl'] = $acl;

        return $this;
    }

    /**
     * Gets created_at
     * @return string
     */
    public function getCreatedAt()
    {
        return $this->container['created_at'];
    }

    /**
     * Sets created_at
     * @param string $created_at A date and time when a Factory has been created.
     * @return $this
     */
    public function setCreatedAt($created_at)
    {
        $this->container['created_at'] = $created_at;

        return $this;
    }

    /**
     * Gets updated_at
     * @return string
     */
    public function getUpdatedAt()
    {
        return $this->container['updated_at'];
    }

    /**
     * Sets updated_at
     * @param string $updated_at A date and time when a Factory has been updated last time.
     * @return $this
     */
    public function setUpdatedAt($updated_at)
    {
        $this->container['updated_at'] = $updated_at;

        return $this;
    }

    /**
     * Gets url
     * @return string
     */
    public function getUrl()
    {
        return $this->container['url'];
    }

    /**
     * Sets url
     * @param string $url An URL pointing to the output_bucket_name.
     * @return $this
     */
    public function setUrl($url)
    {
        $this->container['url'] = $url;

        return $this;
    }

    /**
     * Gets server_side_encryption
     * @return bool
     */
    public function getServerSideEncryption()
    {
        return $this->container['server_side_encryption'];
    }

    /**
     * Sets server_side_encryption
     * @param bool $server_side_encryption Specify if you want to use multi-factor server-side 256-bit AES-256 data encryption with Amazon S3-managed encryption keys (SSE-S3). Each object is encrypted using a unique key which as an additional safeguard is encrypted itself with a master key that S3 regularly rotates. By default this is not set.
     * @return $this
     */
    public function setServerSideEncryption($server_side_encryption)
    {
        $this->container['server_side_encryption'] = $server_side_encryption;

        return $this;
    }

    /**
     * Gets input_bucket_name
     * @return string
     */
    public function getInputBucketName()
    {
        return $this->container['input_bucket_name'];
    }

    /**
     * Sets input_bucket_name
     * @param string $input_bucket_name A name of an input bucket.
     * @return $this
     */
    public function setInputBucketName($input_bucket_name)
    {
        $this->container['input_bucket_name'] = $input_bucket_name;

        return $this;
    }

    /**
     * Gets input_bucket_watch
     * @return bool
     */
    public function getInputBucketWatch()
    {
        return $this->container['input_bucket_watch'];
    }

    /**
     * Sets input_bucket_watch
     * @param bool $input_bucket_watch Determines whether the Factory should be notified about new files added to the input bucket.
     * @return $this
     */
    public function setInputBucketWatch($input_bucket_watch)
    {
        $this->container['input_bucket_watch'] = $input_bucket_watch;

        return $this;
    }

    /**
     * Gets input_bucket_files_map
     * @return string
     */
    public function getInputBucketFilesMap()
    {
        return $this->container['input_bucket_files_map'];
    }

    /**
     * Sets input_bucket_files_map
     * @param string $input_bucket_files_map
     * @return $this
     */
    public function setInputBucketFilesMap($input_bucket_files_map)
    {
        $this->container['input_bucket_files_map'] = $input_bucket_files_map;

        return $this;
    }

    /**
     * Gets input_bucket_sync_every_n_min
     * @return string
     */
    public function getInputBucketSyncEveryNMin()
    {
        return $this->container['input_bucket_sync_every_n_min'];
    }

    /**
     * Sets input_bucket_sync_every_n_min
     * @param string $input_bucket_sync_every_n_min Determines how often the input bucket is synchronised.
     * @return $this
     */
    public function setInputBucketSyncEveryNMin($input_bucket_sync_every_n_min)
    {
        $this->container['input_bucket_sync_every_n_min'] = $input_bucket_sync_every_n_min;

        return $this;
    }

    /**
     * Gets input_bucket_recursive
     * @return string
     */
    public function getInputBucketRecursive()
    {
        return $this->container['input_bucket_recursive'];
    }

    /**
     * Sets input_bucket_recursive
     * @param string $input_bucket_recursive
     * @return $this
     */
    public function setInputBucketRecursive($input_bucket_recursive)
    {
        $this->container['input_bucket_recursive'] = $input_bucket_recursive;

        return $this;
    }

    /**
     * Gets input_bucket_file_pattern
     * @return string
     */
    public function getInputBucketFilePattern()
    {
        return $this->container['input_bucket_file_pattern'];
    }

    /**
     * Sets input_bucket_file_pattern
     * @param string $input_bucket_file_pattern A pattern that will be used to locate files in the input bucket. Valid wildcards might be used.
     * @return $this
     */
    public function setInputBucketFilePattern($input_bucket_file_pattern)
    {
        $this->container['input_bucket_file_pattern'] = $input_bucket_file_pattern;

        return $this;
    }

    /**
     * Gets outputs_path_format
     * @return string
     */
    public function getOutputsPathFormat()
    {
        return $this->container['outputs_path_format'];
    }

    /**
     * Sets outputs_path_format
     * @param string $outputs_path_format
     * @return $this
     */
    public function setOutputsPathFormat($outputs_path_format)
    {
        $this->container['outputs_path_format'] = $outputs_path_format;

        return $this;
    }

    /**
     * Gets storage_provider
     * @return int
     */
    public function getStorageProvider()
    {
        return $this->container['storage_provider'];
    }

    /**
     * Sets storage_provider
     * @param int $storage_provider Specifies which storage provider the factory should use. Available options: S3: 0, Google Cloud Storage: 1, FTP storage: 2, Google Cloud Interoperability Storage: 5, Flip storage: 7, FASP storage: 8, Azure Blob Storage: 9
     * @return $this
     */
    public function setStorageProvider($storage_provider)
    {
        $this->container['storage_provider'] = $storage_provider;

        return $this;
    }

    /**
     * Gets provider_specific_settings
     * @return object
     */
    public function getProviderSpecificSettings()
    {
        return $this->container['provider_specific_settings'];
    }

    /**
     * Sets provider_specific_settings
     * @param object $provider_specific_settings
     * @return $this
     */
    public function setProviderSpecificSettings($provider_specific_settings)
    {
        $this->container['provider_specific_settings'] = $provider_specific_settings;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     * @param  integer $offset Offset
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     * @param  integer $offset Offset
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     * @param  integer $offset Offset
     * @param  mixed   $value  Value to be set
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     * @param  integer $offset Offset
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(\TelestreamCloud\ObjectSerializer::sanitizeForSerialization($this), JSON_PRETTY_PRINT);
        }

        return json_encode(\TelestreamCloud\ObjectSerializer::sanitizeForSerialization($this));
    }
}


