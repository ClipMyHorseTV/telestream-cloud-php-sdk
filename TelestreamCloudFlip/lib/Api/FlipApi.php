<?php
/**
 * FlipApi
 * PHP version 5
 *
 * @category Class
 * @package  TelestreamCloudFlip
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Flip API
 *
 * Description
 *
 * OpenAPI spec version: 2.0.1
 * Contact: cloudsupport@telestream.net
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.3.1
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace TelestreamCloudFlip\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Query;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use GuzzleHttp\Utils;
use TelestreamCloudFlip\ApiException;
use TelestreamCloudFlip\Configuration;
use TelestreamCloudFlip\HeaderSelector;
use TelestreamCloudFlip\ObjectSerializer;

/**
 * FlipApi Class Doc Comment
 *
 * @category Class
 * @package  TelestreamCloudFlip
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class FlipApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation cancelEncoding
     *
     * Cancels an Encoding.
     *
     * @param  string $id Id of an Encoding. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TelestreamCloudFlip\Model\CanceledResponse
     */
    public function cancelEncoding($id, $factory_id)
    {
        list($response) = $this->cancelEncodingWithHttpInfo($id, $factory_id);
        return $response;
    }

    /**
     * Operation cancelEncodingWithHttpInfo
     *
     * Cancels an Encoding.
     *
     * @param  string $id Id of an Encoding. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TelestreamCloudFlip\Model\CanceledResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function cancelEncodingWithHttpInfo($id, $factory_id)
    {
        $returnType = '\TelestreamCloudFlip\Model\CanceledResponse';
        $request = $this->cancelEncodingRequest($id, $factory_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\CanceledResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cancelEncodingAsync
     *
     * Cancels an Encoding.
     *
     * @param  string $id Id of an Encoding. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelEncodingAsync($id, $factory_id)
    {
        return $this->cancelEncodingAsyncWithHttpInfo($id, $factory_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cancelEncodingAsyncWithHttpInfo
     *
     * Cancels an Encoding.
     *
     * @param  string $id Id of an Encoding. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelEncodingAsyncWithHttpInfo($id, $factory_id)
    {
        $returnType = '\TelestreamCloudFlip\Model\CanceledResponse';
        $request = $this->cancelEncodingRequest($id, $factory_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cancelEncoding'
     *
     * @param  string $id Id of an Encoding. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function cancelEncodingRequest($id, $factory_id)
    {
        // verify the required parameter 'id' is set
        if ($id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cancelEncoding'
            );
        }
        // verify the required parameter 'factory_id' is set
        if ($factory_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $factory_id when calling cancelEncoding'
            );
        }

        $resourcePath = '/encodings/{id}/cancel.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($factory_id !== null) {
            $queryParams['factory_id'] = ObjectSerializer::toQueryValue($factory_id);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation copyProfile
     *
     * Copies a given Profile
     *
     * @param  string $id Id of a Profile. (required)
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\CopyProfileBody $copy_profile_body copy_profile_body (required)
     * @param  bool $expand If expand option is set Profile objects will contain all command parameters, even if their value is default. By default this is not set. (optional)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TelestreamCloudFlip\Model\Profile
     */
    public function copyProfile($id, $factory_id, $copy_profile_body, $expand = null)
    {
        list($response) = $this->copyProfileWithHttpInfo($id, $factory_id, $copy_profile_body, $expand);
        return $response;
    }

    /**
     * Operation copyProfileWithHttpInfo
     *
     * Copies a given Profile
     *
     * @param  string $id Id of a Profile. (required)
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\CopyProfileBody $copy_profile_body (required)
     * @param  bool $expand If expand option is set Profile objects will contain all command parameters, even if their value is default. By default this is not set. (optional)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TelestreamCloudFlip\Model\Profile, HTTP status code, HTTP response headers (array of strings)
     */
    public function copyProfileWithHttpInfo($id, $factory_id, $copy_profile_body, $expand = null)
    {
        $returnType = '\TelestreamCloudFlip\Model\Profile';
        $request = $this->copyProfileRequest($id, $factory_id, $copy_profile_body, $expand);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Profile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation copyProfileAsync
     *
     * Copies a given Profile
     *
     * @param  string $id Id of a Profile. (required)
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\CopyProfileBody $copy_profile_body (required)
     * @param  bool $expand If expand option is set Profile objects will contain all command parameters, even if their value is default. By default this is not set. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function copyProfileAsync($id, $factory_id, $copy_profile_body, $expand = null)
    {
        return $this->copyProfileAsyncWithHttpInfo($id, $factory_id, $copy_profile_body, $expand)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation copyProfileAsyncWithHttpInfo
     *
     * Copies a given Profile
     *
     * @param  string $id Id of a Profile. (required)
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\CopyProfileBody $copy_profile_body (required)
     * @param  bool $expand If expand option is set Profile objects will contain all command parameters, even if their value is default. By default this is not set. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function copyProfileAsyncWithHttpInfo($id, $factory_id, $copy_profile_body, $expand = null)
    {
        $returnType = '\TelestreamCloudFlip\Model\Profile';
        $request = $this->copyProfileRequest($id, $factory_id, $copy_profile_body, $expand);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'copyProfile'
     *
     * @param  string $id Id of a Profile. (required)
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\CopyProfileBody $copy_profile_body (required)
     * @param  bool $expand If expand option is set Profile objects will contain all command parameters, even if their value is default. By default this is not set. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function copyProfileRequest($id, $factory_id, $copy_profile_body, $expand = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling copyProfile'
            );
        }
        // verify the required parameter 'factory_id' is set
        if ($factory_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $factory_id when calling copyProfile'
            );
        }
        // verify the required parameter 'copy_profile_body' is set
        if ($copy_profile_body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $copy_profile_body when calling copyProfile'
            );
        }

        $resourcePath = '/profiles/{id}/copy.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($factory_id !== null) {
            $queryParams['factory_id'] = ObjectSerializer::toQueryValue($factory_id);
        }
        // query params
        if ($expand !== null) {
            $queryParams['expand'] = ObjectSerializer::toQueryValue($expand);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($copy_profile_body)) {
            $_tempBody = $copy_profile_body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createEncoding
     *
     * Creates an Encoding
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\CreateEncodingBody $create_encoding_body create_encoding_body (required)
     * @param  bool $screenshots Determines whether the response will include screenshots. By default this is not set. (optional)
     * @param  bool $precise_status Determines whether the response will include a precise status. By default this is not set. (optional)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TelestreamCloudFlip\Model\Encoding
     */
    public function createEncoding($factory_id, $create_encoding_body, $screenshots = null, $precise_status = null)
    {
        list($response) = $this->createEncodingWithHttpInfo($factory_id, $create_encoding_body, $screenshots, $precise_status);
        return $response;
    }

    /**
     * Operation createEncodingWithHttpInfo
     *
     * Creates an Encoding
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\CreateEncodingBody $create_encoding_body (required)
     * @param  bool $screenshots Determines whether the response will include screenshots. By default this is not set. (optional)
     * @param  bool $precise_status Determines whether the response will include a precise status. By default this is not set. (optional)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TelestreamCloudFlip\Model\Encoding, HTTP status code, HTTP response headers (array of strings)
     */
    public function createEncodingWithHttpInfo($factory_id, $create_encoding_body, $screenshots = null, $precise_status = null)
    {
        $returnType = '\TelestreamCloudFlip\Model\Encoding';
        $request = $this->createEncodingRequest($factory_id, $create_encoding_body, $screenshots, $precise_status);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Encoding',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createEncodingAsync
     *
     * Creates an Encoding
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\CreateEncodingBody $create_encoding_body (required)
     * @param  bool $screenshots Determines whether the response will include screenshots. By default this is not set. (optional)
     * @param  bool $precise_status Determines whether the response will include a precise status. By default this is not set. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createEncodingAsync($factory_id, $create_encoding_body, $screenshots = null, $precise_status = null)
    {
        return $this->createEncodingAsyncWithHttpInfo($factory_id, $create_encoding_body, $screenshots, $precise_status)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createEncodingAsyncWithHttpInfo
     *
     * Creates an Encoding
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\CreateEncodingBody $create_encoding_body (required)
     * @param  bool $screenshots Determines whether the response will include screenshots. By default this is not set. (optional)
     * @param  bool $precise_status Determines whether the response will include a precise status. By default this is not set. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createEncodingAsyncWithHttpInfo($factory_id, $create_encoding_body, $screenshots = null, $precise_status = null)
    {
        $returnType = '\TelestreamCloudFlip\Model\Encoding';
        $request = $this->createEncodingRequest($factory_id, $create_encoding_body, $screenshots, $precise_status);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createEncoding'
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\CreateEncodingBody $create_encoding_body (required)
     * @param  bool $screenshots Determines whether the response will include screenshots. By default this is not set. (optional)
     * @param  bool $precise_status Determines whether the response will include a precise status. By default this is not set. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createEncodingRequest($factory_id, $create_encoding_body, $screenshots = null, $precise_status = null)
    {
        // verify the required parameter 'factory_id' is set
        if ($factory_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $factory_id when calling createEncoding'
            );
        }
        // verify the required parameter 'create_encoding_body' is set
        if ($create_encoding_body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_encoding_body when calling createEncoding'
            );
        }

        $resourcePath = '/encodings.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($factory_id !== null) {
            $queryParams['factory_id'] = ObjectSerializer::toQueryValue($factory_id);
        }
        // query params
        if ($screenshots !== null) {
            $queryParams['screenshots'] = ObjectSerializer::toQueryValue($screenshots);
        }
        // query params
        if ($precise_status !== null) {
            $queryParams['precise_status'] = ObjectSerializer::toQueryValue($precise_status);
        }


        // body params
        $_tempBody = null;
        if (isset($create_encoding_body)) {
            $_tempBody = $create_encoding_body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createFactory
     *
     * Creates a new factory
     *
     * @param  \TelestreamCloudFlip\Model\FactoryBody $create_factory_body create_factory_body (required)
     * @param  bool $with_storage_provider if set to &#x60;true&#x60;, results will include a storage provider&#39;s id (optional)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TelestreamCloudFlip\Model\Factory
     */
    public function createFactory($create_factory_body, $with_storage_provider = null)
    {
        list($response) = $this->createFactoryWithHttpInfo($create_factory_body, $with_storage_provider);
        return $response;
    }

    /**
     * Operation createFactoryWithHttpInfo
     *
     * Creates a new factory
     *
     * @param  \TelestreamCloudFlip\Model\FactoryBody $create_factory_body (required)
     * @param  bool $with_storage_provider if set to &#x60;true&#x60;, results will include a storage provider&#39;s id (optional)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TelestreamCloudFlip\Model\Factory, HTTP status code, HTTP response headers (array of strings)
     */
    public function createFactoryWithHttpInfo($create_factory_body, $with_storage_provider = null)
    {
        $returnType = '\TelestreamCloudFlip\Model\Factory';
        $request = $this->createFactoryRequest($create_factory_body, $with_storage_provider);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Factory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createFactoryAsync
     *
     * Creates a new factory
     *
     * @param  \TelestreamCloudFlip\Model\FactoryBody $create_factory_body (required)
     * @param  bool $with_storage_provider if set to &#x60;true&#x60;, results will include a storage provider&#39;s id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFactoryAsync($create_factory_body, $with_storage_provider = null)
    {
        return $this->createFactoryAsyncWithHttpInfo($create_factory_body, $with_storage_provider)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createFactoryAsyncWithHttpInfo
     *
     * Creates a new factory
     *
     * @param  \TelestreamCloudFlip\Model\FactoryBody $create_factory_body (required)
     * @param  bool $with_storage_provider if set to &#x60;true&#x60;, results will include a storage provider&#39;s id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFactoryAsyncWithHttpInfo($create_factory_body, $with_storage_provider = null)
    {
        $returnType = '\TelestreamCloudFlip\Model\Factory';
        $request = $this->createFactoryRequest($create_factory_body, $with_storage_provider);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createFactory'
     *
     * @param  \TelestreamCloudFlip\Model\FactoryBody $create_factory_body (required)
     * @param  bool $with_storage_provider if set to &#x60;true&#x60;, results will include a storage provider&#39;s id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createFactoryRequest($create_factory_body, $with_storage_provider = null)
    {
        // verify the required parameter 'create_factory_body' is set
        if ($create_factory_body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_factory_body when calling createFactory'
            );
        }

        $resourcePath = '/factories.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($with_storage_provider !== null) {
            $queryParams['with_storage_provider'] = ObjectSerializer::toQueryValue($with_storage_provider);
        }


        // body params
        $_tempBody = null;
        if (isset($create_factory_body)) {
            $_tempBody = $create_factory_body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createProfile
     *
     * Creates a Profile
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\ProfileBody $create_profile_body create_profile_body (required)
     * @param  bool $exclude_advanced_services exclude_advanced_services (optional)
     * @param  bool $expand If expand option is set Profile objects will contain all command parameters, even if their value is default. By default it is not set. (optional)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TelestreamCloudFlip\Model\Profile
     */
    public function createProfile($factory_id, $create_profile_body, $exclude_advanced_services = null, $expand = null)
    {
        list($response) = $this->createProfileWithHttpInfo($factory_id, $create_profile_body, $exclude_advanced_services, $expand);
        return $response;
    }

    /**
     * Operation createProfileWithHttpInfo
     *
     * Creates a Profile
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\ProfileBody $create_profile_body (required)
     * @param  bool $exclude_advanced_services (optional)
     * @param  bool $expand If expand option is set Profile objects will contain all command parameters, even if their value is default. By default it is not set. (optional)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TelestreamCloudFlip\Model\Profile, HTTP status code, HTTP response headers (array of strings)
     */
    public function createProfileWithHttpInfo($factory_id, $create_profile_body, $exclude_advanced_services = null, $expand = null)
    {
        $returnType = '\TelestreamCloudFlip\Model\Profile';
        $request = $this->createProfileRequest($factory_id, $create_profile_body, $exclude_advanced_services, $expand);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Profile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createProfileAsync
     *
     * Creates a Profile
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\ProfileBody $create_profile_body (required)
     * @param  bool $exclude_advanced_services (optional)
     * @param  bool $expand If expand option is set Profile objects will contain all command parameters, even if their value is default. By default it is not set. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createProfileAsync($factory_id, $create_profile_body, $exclude_advanced_services = null, $expand = null)
    {
        return $this->createProfileAsyncWithHttpInfo($factory_id, $create_profile_body, $exclude_advanced_services, $expand)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createProfileAsyncWithHttpInfo
     *
     * Creates a Profile
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\ProfileBody $create_profile_body (required)
     * @param  bool $exclude_advanced_services (optional)
     * @param  bool $expand If expand option is set Profile objects will contain all command parameters, even if their value is default. By default it is not set. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createProfileAsyncWithHttpInfo($factory_id, $create_profile_body, $exclude_advanced_services = null, $expand = null)
    {
        $returnType = '\TelestreamCloudFlip\Model\Profile';
        $request = $this->createProfileRequest($factory_id, $create_profile_body, $exclude_advanced_services, $expand);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createProfile'
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\ProfileBody $create_profile_body (required)
     * @param  bool $exclude_advanced_services (optional)
     * @param  bool $expand If expand option is set Profile objects will contain all command parameters, even if their value is default. By default it is not set. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createProfileRequest($factory_id, $create_profile_body, $exclude_advanced_services = null, $expand = null)
    {
        // verify the required parameter 'factory_id' is set
        if ($factory_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $factory_id when calling createProfile'
            );
        }
        // verify the required parameter 'create_profile_body' is set
        if ($create_profile_body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_profile_body when calling createProfile'
            );
        }

        $resourcePath = '/profiles.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($factory_id !== null) {
            $queryParams['factory_id'] = ObjectSerializer::toQueryValue($factory_id);
        }
        // query params
        if ($exclude_advanced_services !== null) {
            $queryParams['exclude_advanced_services'] = ObjectSerializer::toQueryValue($exclude_advanced_services);
        }
        // query params
        if ($expand !== null) {
            $queryParams['expand'] = ObjectSerializer::toQueryValue($expand);
        }


        // body params
        $_tempBody = null;
        if (isset($create_profile_body)) {
            $_tempBody = $create_profile_body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createVideo
     *
     * Creates a Video from a provided source_url.
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\CreateVideoBody $create_video_body create_video_body (required)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TelestreamCloudFlip\Model\Video
     */
    public function createVideo($factory_id, $create_video_body)
    {
        list($response) = $this->createVideoWithHttpInfo($factory_id, $create_video_body);
        return $response;
    }

    /**
     * Operation createVideoWithHttpInfo
     *
     * Creates a Video from a provided source_url.
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\CreateVideoBody $create_video_body (required)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TelestreamCloudFlip\Model\Video, HTTP status code, HTTP response headers (array of strings)
     */
    public function createVideoWithHttpInfo($factory_id, $create_video_body)
    {
        $returnType = '\TelestreamCloudFlip\Model\Video';
        $request = $this->createVideoRequest($factory_id, $create_video_body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Video',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createVideoAsync
     *
     * Creates a Video from a provided source_url.
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\CreateVideoBody $create_video_body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createVideoAsync($factory_id, $create_video_body)
    {
        return $this->createVideoAsyncWithHttpInfo($factory_id, $create_video_body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createVideoAsyncWithHttpInfo
     *
     * Creates a Video from a provided source_url.
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\CreateVideoBody $create_video_body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createVideoAsyncWithHttpInfo($factory_id, $create_video_body)
    {
        $returnType = '\TelestreamCloudFlip\Model\Video';
        $request = $this->createVideoRequest($factory_id, $create_video_body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createVideo'
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\CreateVideoBody $create_video_body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createVideoRequest($factory_id, $create_video_body)
    {
        // verify the required parameter 'factory_id' is set
        if ($factory_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $factory_id when calling createVideo'
            );
        }
        // verify the required parameter 'create_video_body' is set
        if ($create_video_body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_video_body when calling createVideo'
            );
        }

        $resourcePath = '/videos.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($factory_id !== null) {
            $queryParams['factory_id'] = ObjectSerializer::toQueryValue($factory_id);
        }


        // body params
        $_tempBody = null;
        if (isset($create_video_body)) {
            $_tempBody = $create_video_body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createWorkorder
     *
     * Creates a Workorder.
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  string $profile_id Id of a Profile. (optional)
     * @param  \SplFileObject $file Input file. (optional)
     * @param  string $source_url URL pointing to an input file. (optional)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createWorkorder($factory_id, $profile_id = null, $file = null, $source_url = null)
    {
        $this->createWorkorderWithHttpInfo($factory_id, $profile_id, $file, $source_url);
    }

    /**
     * Operation createWorkorderWithHttpInfo
     *
     * Creates a Workorder.
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  string $profile_id Id of a Profile. (optional)
     * @param  \SplFileObject $file Input file. (optional)
     * @param  string $source_url URL pointing to an input file. (optional)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createWorkorderWithHttpInfo($factory_id, $profile_id = null, $file = null, $source_url = null)
    {
        $returnType = '';
        $request = $this->createWorkorderRequest($factory_id, $profile_id, $file, $source_url);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation createWorkorderAsync
     *
     * Creates a Workorder.
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  string $profile_id Id of a Profile. (optional)
     * @param  \SplFileObject $file Input file. (optional)
     * @param  string $source_url URL pointing to an input file. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createWorkorderAsync($factory_id, $profile_id = null, $file = null, $source_url = null)
    {
        return $this->createWorkorderAsyncWithHttpInfo($factory_id, $profile_id, $file, $source_url)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createWorkorderAsyncWithHttpInfo
     *
     * Creates a Workorder.
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  string $profile_id Id of a Profile. (optional)
     * @param  \SplFileObject $file Input file. (optional)
     * @param  string $source_url URL pointing to an input file. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createWorkorderAsyncWithHttpInfo($factory_id, $profile_id = null, $file = null, $source_url = null)
    {
        $returnType = '';
        $request = $this->createWorkorderRequest($factory_id, $profile_id, $file, $source_url);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createWorkorder'
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  string $profile_id Id of a Profile. (optional)
     * @param  \SplFileObject $file Input file. (optional)
     * @param  string $source_url URL pointing to an input file. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createWorkorderRequest($factory_id, $profile_id = null, $file = null, $source_url = null)
    {
        // verify the required parameter 'factory_id' is set
        if ($factory_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $factory_id when calling createWorkorder'
            );
        }

        $resourcePath = '/workorders.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($factory_id !== null) {
            $queryParams['factory_id'] = ObjectSerializer::toQueryValue($factory_id);
        }


        // form params
        if ($profile_id !== null) {
            $formParams['profile_id'] = ObjectSerializer::toFormValue($profile_id);
        }
        // form params
        if ($file !== null) {
            $multipart = true;
            $formParams['file'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($file), 'rb');
        }
        // form params
        if ($source_url !== null) {
            $formParams['source_url'] = ObjectSerializer::toFormValue($source_url);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteEncoding
     *
     * Deletes an Encoding from both Telestream Cloud and your storage. Returns an information whether the operation was successful.
     *
     * @param  string $id Id of an Encoding. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TelestreamCloudFlip\Model\DeletedResponse
     */
    public function deleteEncoding($id, $factory_id)
    {
        list($response) = $this->deleteEncodingWithHttpInfo($id, $factory_id);
        return $response;
    }

    /**
     * Operation deleteEncodingWithHttpInfo
     *
     * Deletes an Encoding from both Telestream Cloud and your storage. Returns an information whether the operation was successful.
     *
     * @param  string $id Id of an Encoding. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TelestreamCloudFlip\Model\DeletedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteEncodingWithHttpInfo($id, $factory_id)
    {
        $returnType = '\TelestreamCloudFlip\Model\DeletedResponse';
        $request = $this->deleteEncodingRequest($id, $factory_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\DeletedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteEncodingAsync
     *
     * Deletes an Encoding from both Telestream Cloud and your storage. Returns an information whether the operation was successful.
     *
     * @param  string $id Id of an Encoding. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteEncodingAsync($id, $factory_id)
    {
        return $this->deleteEncodingAsyncWithHttpInfo($id, $factory_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteEncodingAsyncWithHttpInfo
     *
     * Deletes an Encoding from both Telestream Cloud and your storage. Returns an information whether the operation was successful.
     *
     * @param  string $id Id of an Encoding. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteEncodingAsyncWithHttpInfo($id, $factory_id)
    {
        $returnType = '\TelestreamCloudFlip\Model\DeletedResponse';
        $request = $this->deleteEncodingRequest($id, $factory_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteEncoding'
     *
     * @param  string $id Id of an Encoding. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteEncodingRequest($id, $factory_id)
    {
        // verify the required parameter 'id' is set
        if ($id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteEncoding'
            );
        }
        // verify the required parameter 'factory_id' is set
        if ($factory_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $factory_id when calling deleteEncoding'
            );
        }

        $resourcePath = '/encodings/{id}.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($factory_id !== null) {
            $queryParams['factory_id'] = ObjectSerializer::toQueryValue($factory_id);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteProfile
     *
     * Deletes a given Profile
     *
     * @param  string $id Id of a Profile (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TelestreamCloudFlip\Model\DeletedResponse
     */
    public function deleteProfile($id, $factory_id)
    {
        list($response) = $this->deleteProfileWithHttpInfo($id, $factory_id);
        return $response;
    }

    /**
     * Operation deleteProfileWithHttpInfo
     *
     * Deletes a given Profile
     *
     * @param  string $id Id of a Profile (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TelestreamCloudFlip\Model\DeletedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteProfileWithHttpInfo($id, $factory_id)
    {
        $returnType = '\TelestreamCloudFlip\Model\DeletedResponse';
        $request = $this->deleteProfileRequest($id, $factory_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\DeletedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteProfileAsync
     *
     * Deletes a given Profile
     *
     * @param  string $id Id of a Profile (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteProfileAsync($id, $factory_id)
    {
        return $this->deleteProfileAsyncWithHttpInfo($id, $factory_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteProfileAsyncWithHttpInfo
     *
     * Deletes a given Profile
     *
     * @param  string $id Id of a Profile (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteProfileAsyncWithHttpInfo($id, $factory_id)
    {
        $returnType = '\TelestreamCloudFlip\Model\DeletedResponse';
        $request = $this->deleteProfileRequest($id, $factory_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteProfile'
     *
     * @param  string $id Id of a Profile (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteProfileRequest($id, $factory_id)
    {
        // verify the required parameter 'id' is set
        if ($id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteProfile'
            );
        }
        // verify the required parameter 'factory_id' is set
        if ($factory_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $factory_id when calling deleteProfile'
            );
        }

        $resourcePath = '/profiles/{id}.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($factory_id !== null) {
            $queryParams['factory_id'] = ObjectSerializer::toQueryValue($factory_id);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteVideo
     *
     * Deletes a Video object.
     *
     * @param  string $id Id of a Video. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TelestreamCloudFlip\Model\DeletedResponse
     */
    public function deleteVideo($id, $factory_id)
    {
        list($response) = $this->deleteVideoWithHttpInfo($id, $factory_id);
        return $response;
    }

    /**
     * Operation deleteVideoWithHttpInfo
     *
     * Deletes a Video object.
     *
     * @param  string $id Id of a Video. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TelestreamCloudFlip\Model\DeletedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteVideoWithHttpInfo($id, $factory_id)
    {
        $returnType = '\TelestreamCloudFlip\Model\DeletedResponse';
        $request = $this->deleteVideoRequest($id, $factory_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\DeletedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteVideoAsync
     *
     * Deletes a Video object.
     *
     * @param  string $id Id of a Video. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteVideoAsync($id, $factory_id)
    {
        return $this->deleteVideoAsyncWithHttpInfo($id, $factory_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteVideoAsyncWithHttpInfo
     *
     * Deletes a Video object.
     *
     * @param  string $id Id of a Video. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteVideoAsyncWithHttpInfo($id, $factory_id)
    {
        $returnType = '\TelestreamCloudFlip\Model\DeletedResponse';
        $request = $this->deleteVideoRequest($id, $factory_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteVideo'
     *
     * @param  string $id Id of a Video. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteVideoRequest($id, $factory_id)
    {
        // verify the required parameter 'id' is set
        if ($id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteVideo'
            );
        }
        // verify the required parameter 'factory_id' is set
        if ($factory_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $factory_id when calling deleteVideo'
            );
        }

        $resourcePath = '/videos/{id}.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($factory_id !== null) {
            $queryParams['factory_id'] = ObjectSerializer::toQueryValue($factory_id);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteVideoSource
     *
     * Delete a video's source file.
     *
     * @param  string $id Id of a Video. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TelestreamCloudFlip\Model\DeletedResponse
     */
    public function deleteVideoSource($id, $factory_id)
    {
        list($response) = $this->deleteVideoSourceWithHttpInfo($id, $factory_id);
        return $response;
    }

    /**
     * Operation deleteVideoSourceWithHttpInfo
     *
     * Delete a video's source file.
     *
     * @param  string $id Id of a Video. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TelestreamCloudFlip\Model\DeletedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteVideoSourceWithHttpInfo($id, $factory_id)
    {
        $returnType = '\TelestreamCloudFlip\Model\DeletedResponse';
        $request = $this->deleteVideoSourceRequest($id, $factory_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\DeletedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteVideoSourceAsync
     *
     * Delete a video's source file.
     *
     * @param  string $id Id of a Video. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteVideoSourceAsync($id, $factory_id)
    {
        return $this->deleteVideoSourceAsyncWithHttpInfo($id, $factory_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteVideoSourceAsyncWithHttpInfo
     *
     * Delete a video's source file.
     *
     * @param  string $id Id of a Video. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteVideoSourceAsyncWithHttpInfo($id, $factory_id)
    {
        $returnType = '\TelestreamCloudFlip\Model\DeletedResponse';
        $request = $this->deleteVideoSourceRequest($id, $factory_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteVideoSource'
     *
     * @param  string $id Id of a Video. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteVideoSourceRequest($id, $factory_id)
    {
        // verify the required parameter 'id' is set
        if ($id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteVideoSource'
            );
        }
        // verify the required parameter 'factory_id' is set
        if ($factory_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $factory_id when calling deleteVideoSource'
            );
        }

        $resourcePath = '/videos/{id}/source.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($factory_id !== null) {
            $queryParams['factory_id'] = ObjectSerializer::toQueryValue($factory_id);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation encoding
     *
     * Returns an Encoding object.
     *
     * @param  string $id Id of an Encoding. (required)
     * @param  string $factory_id Id of a Factory. (required)
     * @param  bool $screenshots Determines whether the response will include screenshots. By default this is not set. (optional)
     * @param  bool $precise_status Determines whether the response will include a precise status. By default this is not set. (optional)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TelestreamCloudFlip\Model\Encoding
     */
    public function encoding($id, $factory_id, $screenshots = null, $precise_status = null)
    {
        list($response) = $this->encodingWithHttpInfo($id, $factory_id, $screenshots, $precise_status);
        return $response;
    }

    /**
     * Operation encodingWithHttpInfo
     *
     * Returns an Encoding object.
     *
     * @param  string $id Id of an Encoding. (required)
     * @param  string $factory_id Id of a Factory. (required)
     * @param  bool $screenshots Determines whether the response will include screenshots. By default this is not set. (optional)
     * @param  bool $precise_status Determines whether the response will include a precise status. By default this is not set. (optional)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TelestreamCloudFlip\Model\Encoding, HTTP status code, HTTP response headers (array of strings)
     */
    public function encodingWithHttpInfo($id, $factory_id, $screenshots = null, $precise_status = null)
    {
        $returnType = '\TelestreamCloudFlip\Model\Encoding';
        $request = $this->encodingRequest($id, $factory_id, $screenshots, $precise_status);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Encoding',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation encodingAsync
     *
     * Returns an Encoding object.
     *
     * @param  string $id Id of an Encoding. (required)
     * @param  string $factory_id Id of a Factory. (required)
     * @param  bool $screenshots Determines whether the response will include screenshots. By default this is not set. (optional)
     * @param  bool $precise_status Determines whether the response will include a precise status. By default this is not set. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function encodingAsync($id, $factory_id, $screenshots = null, $precise_status = null)
    {
        return $this->encodingAsyncWithHttpInfo($id, $factory_id, $screenshots, $precise_status)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation encodingAsyncWithHttpInfo
     *
     * Returns an Encoding object.
     *
     * @param  string $id Id of an Encoding. (required)
     * @param  string $factory_id Id of a Factory. (required)
     * @param  bool $screenshots Determines whether the response will include screenshots. By default this is not set. (optional)
     * @param  bool $precise_status Determines whether the response will include a precise status. By default this is not set. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function encodingAsyncWithHttpInfo($id, $factory_id, $screenshots = null, $precise_status = null)
    {
        $returnType = '\TelestreamCloudFlip\Model\Encoding';
        $request = $this->encodingRequest($id, $factory_id, $screenshots, $precise_status);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'encoding'
     *
     * @param  string $id Id of an Encoding. (required)
     * @param  string $factory_id Id of a Factory. (required)
     * @param  bool $screenshots Determines whether the response will include screenshots. By default this is not set. (optional)
     * @param  bool $precise_status Determines whether the response will include a precise status. By default this is not set. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function encodingRequest($id, $factory_id, $screenshots = null, $precise_status = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling encoding'
            );
        }
        // verify the required parameter 'factory_id' is set
        if ($factory_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $factory_id when calling encoding'
            );
        }

        $resourcePath = '/encodings/{id}.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($factory_id !== null) {
            $queryParams['factory_id'] = ObjectSerializer::toQueryValue($factory_id);
        }
        // query params
        if ($screenshots !== null) {
            $queryParams['screenshots'] = ObjectSerializer::toQueryValue($screenshots);
        }
        // query params
        if ($precise_status !== null) {
            $queryParams['precise_status'] = ObjectSerializer::toQueryValue($precise_status);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation encodings
     *
     * Returns a list of Encoding objects
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  string $video_id Id of a Video. When specified, the resulting list will contain videos that belong to the Video. (optional)
     * @param  string $status One of &#x60;success&#x60;, &#x60;fail&#x60;, &#x60;processing&#x60;. When specified, the resulting list will contain ecodings filtered by status. (optional)
     * @param  string $profile_id Filter by profile_id. (optional)
     * @param  string $profile_name Filter by profile_name. (optional)
     * @param  int $page A page to be fetched. Default is &#x60;1&#x60;. (optional)
     * @param  int $per_page A number of results per page. Default is &#x60;100&#x60;. (optional)
     * @param  bool $screenshots Determines whether the response will include screenshots. By default this is not set. (optional)
     * @param  bool $precise_status Determines whether the response will include a precise status. By default this is not set. (optional)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TelestreamCloudFlip\Model\PaginatedEncodingsCollection
     */
    public function encodings($factory_id, $video_id = null, $status = null, $profile_id = null, $profile_name = null, $page = null, $per_page = null, $screenshots = null, $precise_status = null)
    {
        list($response) = $this->encodingsWithHttpInfo($factory_id, $video_id, $status, $profile_id, $profile_name, $page, $per_page, $screenshots, $precise_status);
        return $response;
    }

    /**
     * Operation encodingsWithHttpInfo
     *
     * Returns a list of Encoding objects
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  string $video_id Id of a Video. When specified, the resulting list will contain videos that belong to the Video. (optional)
     * @param  string $status One of &#x60;success&#x60;, &#x60;fail&#x60;, &#x60;processing&#x60;. When specified, the resulting list will contain ecodings filtered by status. (optional)
     * @param  string $profile_id Filter by profile_id. (optional)
     * @param  string $profile_name Filter by profile_name. (optional)
     * @param  int $page A page to be fetched. Default is &#x60;1&#x60;. (optional)
     * @param  int $per_page A number of results per page. Default is &#x60;100&#x60;. (optional)
     * @param  bool $screenshots Determines whether the response will include screenshots. By default this is not set. (optional)
     * @param  bool $precise_status Determines whether the response will include a precise status. By default this is not set. (optional)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TelestreamCloudFlip\Model\PaginatedEncodingsCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function encodingsWithHttpInfo($factory_id, $video_id = null, $status = null, $profile_id = null, $profile_name = null, $page = null, $per_page = null, $screenshots = null, $precise_status = null)
    {
        $returnType = '\TelestreamCloudFlip\Model\PaginatedEncodingsCollection';
        $request = $this->encodingsRequest($factory_id, $video_id, $status, $profile_id, $profile_name, $page, $per_page, $screenshots, $precise_status);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\PaginatedEncodingsCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation encodingsAsync
     *
     * Returns a list of Encoding objects
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  string $video_id Id of a Video. When specified, the resulting list will contain videos that belong to the Video. (optional)
     * @param  string $status One of &#x60;success&#x60;, &#x60;fail&#x60;, &#x60;processing&#x60;. When specified, the resulting list will contain ecodings filtered by status. (optional)
     * @param  string $profile_id Filter by profile_id. (optional)
     * @param  string $profile_name Filter by profile_name. (optional)
     * @param  int $page A page to be fetched. Default is &#x60;1&#x60;. (optional)
     * @param  int $per_page A number of results per page. Default is &#x60;100&#x60;. (optional)
     * @param  bool $screenshots Determines whether the response will include screenshots. By default this is not set. (optional)
     * @param  bool $precise_status Determines whether the response will include a precise status. By default this is not set. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function encodingsAsync($factory_id, $video_id = null, $status = null, $profile_id = null, $profile_name = null, $page = null, $per_page = null, $screenshots = null, $precise_status = null)
    {
        return $this->encodingsAsyncWithHttpInfo($factory_id, $video_id, $status, $profile_id, $profile_name, $page, $per_page, $screenshots, $precise_status)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation encodingsAsyncWithHttpInfo
     *
     * Returns a list of Encoding objects
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  string $video_id Id of a Video. When specified, the resulting list will contain videos that belong to the Video. (optional)
     * @param  string $status One of &#x60;success&#x60;, &#x60;fail&#x60;, &#x60;processing&#x60;. When specified, the resulting list will contain ecodings filtered by status. (optional)
     * @param  string $profile_id Filter by profile_id. (optional)
     * @param  string $profile_name Filter by profile_name. (optional)
     * @param  int $page A page to be fetched. Default is &#x60;1&#x60;. (optional)
     * @param  int $per_page A number of results per page. Default is &#x60;100&#x60;. (optional)
     * @param  bool $screenshots Determines whether the response will include screenshots. By default this is not set. (optional)
     * @param  bool $precise_status Determines whether the response will include a precise status. By default this is not set. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function encodingsAsyncWithHttpInfo($factory_id, $video_id = null, $status = null, $profile_id = null, $profile_name = null, $page = null, $per_page = null, $screenshots = null, $precise_status = null)
    {
        $returnType = '\TelestreamCloudFlip\Model\PaginatedEncodingsCollection';
        $request = $this->encodingsRequest($factory_id, $video_id, $status, $profile_id, $profile_name, $page, $per_page, $screenshots, $precise_status);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'encodings'
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  string $video_id Id of a Video. When specified, the resulting list will contain videos that belong to the Video. (optional)
     * @param  string $status One of &#x60;success&#x60;, &#x60;fail&#x60;, &#x60;processing&#x60;. When specified, the resulting list will contain ecodings filtered by status. (optional)
     * @param  string $profile_id Filter by profile_id. (optional)
     * @param  string $profile_name Filter by profile_name. (optional)
     * @param  int $page A page to be fetched. Default is &#x60;1&#x60;. (optional)
     * @param  int $per_page A number of results per page. Default is &#x60;100&#x60;. (optional)
     * @param  bool $screenshots Determines whether the response will include screenshots. By default this is not set. (optional)
     * @param  bool $precise_status Determines whether the response will include a precise status. By default this is not set. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function encodingsRequest($factory_id, $video_id = null, $status = null, $profile_id = null, $profile_name = null, $page = null, $per_page = null, $screenshots = null, $precise_status = null)
    {
        // verify the required parameter 'factory_id' is set
        if ($factory_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $factory_id when calling encodings'
            );
        }

        $resourcePath = '/encodings.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($factory_id !== null) {
            $queryParams['factory_id'] = ObjectSerializer::toQueryValue($factory_id);
        }
        // query params
        if ($video_id !== null) {
            $queryParams['video_id'] = ObjectSerializer::toQueryValue($video_id);
        }
        // query params
        if ($status !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($status);
        }
        // query params
        if ($profile_id !== null) {
            $queryParams['profile_id'] = ObjectSerializer::toQueryValue($profile_id);
        }
        // query params
        if ($profile_name !== null) {
            $queryParams['profile_name'] = ObjectSerializer::toQueryValue($profile_name);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($per_page !== null) {
            $queryParams['per_page'] = ObjectSerializer::toQueryValue($per_page);
        }
        // query params
        if ($screenshots !== null) {
            $queryParams['screenshots'] = ObjectSerializer::toQueryValue($screenshots);
        }
        // query params
        if ($precise_status !== null) {
            $queryParams['precise_status'] = ObjectSerializer::toQueryValue($precise_status);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation encodingsCount
     *
     * Returns a number of Encoding objects created using a given factory.
     *
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TelestreamCloudFlip\Model\CountResponse
     */
    public function encodingsCount($factory_id)
    {
        list($response) = $this->encodingsCountWithHttpInfo($factory_id);
        return $response;
    }

    /**
     * Operation encodingsCountWithHttpInfo
     *
     * Returns a number of Encoding objects created using a given factory.
     *
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TelestreamCloudFlip\Model\CountResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function encodingsCountWithHttpInfo($factory_id)
    {
        $returnType = '\TelestreamCloudFlip\Model\CountResponse';
        $request = $this->encodingsCountRequest($factory_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\CountResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation encodingsCountAsync
     *
     * Returns a number of Encoding objects created using a given factory.
     *
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function encodingsCountAsync($factory_id)
    {
        return $this->encodingsCountAsyncWithHttpInfo($factory_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation encodingsCountAsyncWithHttpInfo
     *
     * Returns a number of Encoding objects created using a given factory.
     *
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function encodingsCountAsyncWithHttpInfo($factory_id)
    {
        $returnType = '\TelestreamCloudFlip\Model\CountResponse';
        $request = $this->encodingsCountRequest($factory_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'encodingsCount'
     *
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function encodingsCountRequest($factory_id)
    {
        // verify the required parameter 'factory_id' is set
        if ($factory_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $factory_id when calling encodingsCount'
            );
        }

        $resourcePath = '/encodings/count.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($factory_id !== null) {
            $queryParams['factory_id'] = ObjectSerializer::toQueryValue($factory_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation factories
     *
     * Returns a collection of Factory objects.
     *
     * @param  int $page A page to be fetched. Default is &#x60;1&#x60;. (optional)
     * @param  int $per_page A number of results per page. Default is &#x60;100&#x60;. (optional)
     * @param  bool $with_storage_provider if set to &#x60;true&#x60;, results will include a storage provider&#39;s id (optional)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TelestreamCloudFlip\Model\PaginatedFactoryCollection
     */
    public function factories($page = null, $per_page = null, $with_storage_provider = null)
    {
        list($response) = $this->factoriesWithHttpInfo($page, $per_page, $with_storage_provider);
        return $response;
    }

    /**
     * Operation factoriesWithHttpInfo
     *
     * Returns a collection of Factory objects.
     *
     * @param  int $page A page to be fetched. Default is &#x60;1&#x60;. (optional)
     * @param  int $per_page A number of results per page. Default is &#x60;100&#x60;. (optional)
     * @param  bool $with_storage_provider if set to &#x60;true&#x60;, results will include a storage provider&#39;s id (optional)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TelestreamCloudFlip\Model\PaginatedFactoryCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function factoriesWithHttpInfo($page = null, $per_page = null, $with_storage_provider = null)
    {
        $returnType = '\TelestreamCloudFlip\Model\PaginatedFactoryCollection';
        $request = $this->factoriesRequest($page, $per_page, $with_storage_provider);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\PaginatedFactoryCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation factoriesAsync
     *
     * Returns a collection of Factory objects.
     *
     * @param  int $page A page to be fetched. Default is &#x60;1&#x60;. (optional)
     * @param  int $per_page A number of results per page. Default is &#x60;100&#x60;. (optional)
     * @param  bool $with_storage_provider if set to &#x60;true&#x60;, results will include a storage provider&#39;s id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function factoriesAsync($page = null, $per_page = null, $with_storage_provider = null)
    {
        return $this->factoriesAsyncWithHttpInfo($page, $per_page, $with_storage_provider)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation factoriesAsyncWithHttpInfo
     *
     * Returns a collection of Factory objects.
     *
     * @param  int $page A page to be fetched. Default is &#x60;1&#x60;. (optional)
     * @param  int $per_page A number of results per page. Default is &#x60;100&#x60;. (optional)
     * @param  bool $with_storage_provider if set to &#x60;true&#x60;, results will include a storage provider&#39;s id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function factoriesAsyncWithHttpInfo($page = null, $per_page = null, $with_storage_provider = null)
    {
        $returnType = '\TelestreamCloudFlip\Model\PaginatedFactoryCollection';
        $request = $this->factoriesRequest($page, $per_page, $with_storage_provider);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'factories'
     *
     * @param  int $page A page to be fetched. Default is &#x60;1&#x60;. (optional)
     * @param  int $per_page A number of results per page. Default is &#x60;100&#x60;. (optional)
     * @param  bool $with_storage_provider if set to &#x60;true&#x60;, results will include a storage provider&#39;s id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function factoriesRequest($page = null, $per_page = null, $with_storage_provider = null)
    {

        $resourcePath = '/factories.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($per_page !== null) {
            $queryParams['per_page'] = ObjectSerializer::toQueryValue($per_page);
        }
        // query params
        if ($with_storage_provider !== null) {
            $queryParams['with_storage_provider'] = ObjectSerializer::toQueryValue($with_storage_provider);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation factory
     *
     * Returns a Factory object.
     *
     * @param  string $id id of a factory (required)
     * @param  bool $with_storage_provider if set to &#x60;true&#x60;, results will include a storage provider&#39;s id (optional)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TelestreamCloudFlip\Model\Factory
     */
    public function factory($id, $with_storage_provider = null)
    {
        list($response) = $this->factoryWithHttpInfo($id, $with_storage_provider);
        return $response;
    }

    /**
     * Operation factoryWithHttpInfo
     *
     * Returns a Factory object.
     *
     * @param  string $id id of a factory (required)
     * @param  bool $with_storage_provider if set to &#x60;true&#x60;, results will include a storage provider&#39;s id (optional)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TelestreamCloudFlip\Model\Factory, HTTP status code, HTTP response headers (array of strings)
     */
    public function factoryWithHttpInfo($id, $with_storage_provider = null)
    {
        $returnType = '\TelestreamCloudFlip\Model\Factory';
        $request = $this->factoryRequest($id, $with_storage_provider);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Factory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation factoryAsync
     *
     * Returns a Factory object.
     *
     * @param  string $id id of a factory (required)
     * @param  bool $with_storage_provider if set to &#x60;true&#x60;, results will include a storage provider&#39;s id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function factoryAsync($id, $with_storage_provider = null)
    {
        return $this->factoryAsyncWithHttpInfo($id, $with_storage_provider)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation factoryAsyncWithHttpInfo
     *
     * Returns a Factory object.
     *
     * @param  string $id id of a factory (required)
     * @param  bool $with_storage_provider if set to &#x60;true&#x60;, results will include a storage provider&#39;s id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function factoryAsyncWithHttpInfo($id, $with_storage_provider = null)
    {
        $returnType = '\TelestreamCloudFlip\Model\Factory';
        $request = $this->factoryRequest($id, $with_storage_provider);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'factory'
     *
     * @param  string $id id of a factory (required)
     * @param  bool $with_storage_provider if set to &#x60;true&#x60;, results will include a storage provider&#39;s id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function factoryRequest($id, $with_storage_provider = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling factory'
            );
        }

        $resourcePath = '/factories/{id}.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($with_storage_provider !== null) {
            $queryParams['with_storage_provider'] = ObjectSerializer::toQueryValue($with_storage_provider);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation notifications
     *
     * Returns a Factory's notification settings.
     *
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TelestreamCloudFlip\Model\CloudNotificationSettings
     */
    public function notifications($factory_id)
    {
        list($response) = $this->notificationsWithHttpInfo($factory_id);
        return $response;
    }

    /**
     * Operation notificationsWithHttpInfo
     *
     * Returns a Factory's notification settings.
     *
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TelestreamCloudFlip\Model\CloudNotificationSettings, HTTP status code, HTTP response headers (array of strings)
     */
    public function notificationsWithHttpInfo($factory_id)
    {
        $returnType = '\TelestreamCloudFlip\Model\CloudNotificationSettings';
        $request = $this->notificationsRequest($factory_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\CloudNotificationSettings',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation notificationsAsync
     *
     * Returns a Factory's notification settings.
     *
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationsAsync($factory_id)
    {
        return $this->notificationsAsyncWithHttpInfo($factory_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation notificationsAsyncWithHttpInfo
     *
     * Returns a Factory's notification settings.
     *
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationsAsyncWithHttpInfo($factory_id)
    {
        $returnType = '\TelestreamCloudFlip\Model\CloudNotificationSettings';
        $request = $this->notificationsRequest($factory_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'notifications'
     *
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function notificationsRequest($factory_id)
    {
        // verify the required parameter 'factory_id' is set
        if ($factory_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $factory_id when calling notifications'
            );
        }

        $resourcePath = '/notifications.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($factory_id !== null) {
            $queryParams['factory_id'] = ObjectSerializer::toQueryValue($factory_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation profile
     *
     * Returns a Profile object.
     *
     * @param  string $id_or_name A name or an id of a Profile. (required)
     * @param  string $factory_id Id of a Factory. (required)
     * @param  bool $expand If expand option is set Profile objects will contain all command parameters, even if their value is default. By default this is not set. (optional)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TelestreamCloudFlip\Model\Profile
     */
    public function profile($id_or_name, $factory_id, $expand = null)
    {
        list($response) = $this->profileWithHttpInfo($id_or_name, $factory_id, $expand);
        return $response;
    }

    /**
     * Operation profileWithHttpInfo
     *
     * Returns a Profile object.
     *
     * @param  string $id_or_name A name or an id of a Profile. (required)
     * @param  string $factory_id Id of a Factory. (required)
     * @param  bool $expand If expand option is set Profile objects will contain all command parameters, even if their value is default. By default this is not set. (optional)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TelestreamCloudFlip\Model\Profile, HTTP status code, HTTP response headers (array of strings)
     */
    public function profileWithHttpInfo($id_or_name, $factory_id, $expand = null)
    {
        $returnType = '\TelestreamCloudFlip\Model\Profile';
        $request = $this->profileRequest($id_or_name, $factory_id, $expand);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Profile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation profileAsync
     *
     * Returns a Profile object.
     *
     * @param  string $id_or_name A name or an id of a Profile. (required)
     * @param  string $factory_id Id of a Factory. (required)
     * @param  bool $expand If expand option is set Profile objects will contain all command parameters, even if their value is default. By default this is not set. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function profileAsync($id_or_name, $factory_id, $expand = null)
    {
        return $this->profileAsyncWithHttpInfo($id_or_name, $factory_id, $expand)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation profileAsyncWithHttpInfo
     *
     * Returns a Profile object.
     *
     * @param  string $id_or_name A name or an id of a Profile. (required)
     * @param  string $factory_id Id of a Factory. (required)
     * @param  bool $expand If expand option is set Profile objects will contain all command parameters, even if their value is default. By default this is not set. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function profileAsyncWithHttpInfo($id_or_name, $factory_id, $expand = null)
    {
        $returnType = '\TelestreamCloudFlip\Model\Profile';
        $request = $this->profileRequest($id_or_name, $factory_id, $expand);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'profile'
     *
     * @param  string $id_or_name A name or an id of a Profile. (required)
     * @param  string $factory_id Id of a Factory. (required)
     * @param  bool $expand If expand option is set Profile objects will contain all command parameters, even if their value is default. By default this is not set. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function profileRequest($id_or_name, $factory_id, $expand = null)
    {
        // verify the required parameter 'id_or_name' is set
        if ($id_or_name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id_or_name when calling profile'
            );
        }
        // verify the required parameter 'factory_id' is set
        if ($factory_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $factory_id when calling profile'
            );
        }

        $resourcePath = '/profiles/{id_or_name}.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($factory_id !== null) {
            $queryParams['factory_id'] = ObjectSerializer::toQueryValue($factory_id);
        }
        // query params
        if ($expand !== null) {
            $queryParams['expand'] = ObjectSerializer::toQueryValue($expand);
        }

        // path params
        if ($id_or_name !== null) {
            $resourcePath = str_replace(
                '{' . 'id_or_name' . '}',
                ObjectSerializer::toPathValue($id_or_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation profileEncodings
     *
     * Returns a list of Encodings that belong to a Profile.
     *
     * @param  string $id_or_name Id or name of a Profile. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TelestreamCloudFlip\Model\PaginatedEncodingsCollection
     */
    public function profileEncodings($id_or_name, $factory_id)
    {
        list($response) = $this->profileEncodingsWithHttpInfo($id_or_name, $factory_id);
        return $response;
    }

    /**
     * Operation profileEncodingsWithHttpInfo
     *
     * Returns a list of Encodings that belong to a Profile.
     *
     * @param  string $id_or_name Id or name of a Profile. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TelestreamCloudFlip\Model\PaginatedEncodingsCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function profileEncodingsWithHttpInfo($id_or_name, $factory_id)
    {
        $returnType = '\TelestreamCloudFlip\Model\PaginatedEncodingsCollection';
        $request = $this->profileEncodingsRequest($id_or_name, $factory_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\PaginatedEncodingsCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation profileEncodingsAsync
     *
     * Returns a list of Encodings that belong to a Profile.
     *
     * @param  string $id_or_name Id or name of a Profile. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function profileEncodingsAsync($id_or_name, $factory_id)
    {
        return $this->profileEncodingsAsyncWithHttpInfo($id_or_name, $factory_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation profileEncodingsAsyncWithHttpInfo
     *
     * Returns a list of Encodings that belong to a Profile.
     *
     * @param  string $id_or_name Id or name of a Profile. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function profileEncodingsAsyncWithHttpInfo($id_or_name, $factory_id)
    {
        $returnType = '\TelestreamCloudFlip\Model\PaginatedEncodingsCollection';
        $request = $this->profileEncodingsRequest($id_or_name, $factory_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'profileEncodings'
     *
     * @param  string $id_or_name Id or name of a Profile. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function profileEncodingsRequest($id_or_name, $factory_id)
    {
        // verify the required parameter 'id_or_name' is set
        if ($id_or_name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id_or_name when calling profileEncodings'
            );
        }
        // verify the required parameter 'factory_id' is set
        if ($factory_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $factory_id when calling profileEncodings'
            );
        }

        $resourcePath = '/profiles/{id_or_name}/encodings.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($factory_id !== null) {
            $queryParams['factory_id'] = ObjectSerializer::toQueryValue($factory_id);
        }

        // path params
        if ($id_or_name !== null) {
            $resourcePath = str_replace(
                '{' . 'id_or_name' . '}',
                ObjectSerializer::toPathValue($id_or_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation profiles
     *
     * Returns a collection of Profile objects.
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  bool $exclude_advanced_services Determine whether exclude Advanced Services profiles from the results. By default this is not set. (optional)
     * @param  bool $expand If expand option is set Profile objects will contain all command parameters, even if their value is default. By default this is not set. (optional)
     * @param  int $page A page to be fetched. Default is &#x60;1&#x60;. (optional)
     * @param  int $per_page A number of results per page. Default is &#x60;100&#x60;. (optional)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TelestreamCloudFlip\Model\PaginatedProfilesCollection
     */
    public function profiles($factory_id, $exclude_advanced_services = null, $expand = null, $page = null, $per_page = null)
    {
        list($response) = $this->profilesWithHttpInfo($factory_id, $exclude_advanced_services, $expand, $page, $per_page);
        return $response;
    }

    /**
     * Operation profilesWithHttpInfo
     *
     * Returns a collection of Profile objects.
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  bool $exclude_advanced_services Determine whether exclude Advanced Services profiles from the results. By default this is not set. (optional)
     * @param  bool $expand If expand option is set Profile objects will contain all command parameters, even if their value is default. By default this is not set. (optional)
     * @param  int $page A page to be fetched. Default is &#x60;1&#x60;. (optional)
     * @param  int $per_page A number of results per page. Default is &#x60;100&#x60;. (optional)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TelestreamCloudFlip\Model\PaginatedProfilesCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function profilesWithHttpInfo($factory_id, $exclude_advanced_services = null, $expand = null, $page = null, $per_page = null)
    {
        $returnType = '\TelestreamCloudFlip\Model\PaginatedProfilesCollection';
        $request = $this->profilesRequest($factory_id, $exclude_advanced_services, $expand, $page, $per_page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\PaginatedProfilesCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation profilesAsync
     *
     * Returns a collection of Profile objects.
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  bool $exclude_advanced_services Determine whether exclude Advanced Services profiles from the results. By default this is not set. (optional)
     * @param  bool $expand If expand option is set Profile objects will contain all command parameters, even if their value is default. By default this is not set. (optional)
     * @param  int $page A page to be fetched. Default is &#x60;1&#x60;. (optional)
     * @param  int $per_page A number of results per page. Default is &#x60;100&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function profilesAsync($factory_id, $exclude_advanced_services = null, $expand = null, $page = null, $per_page = null)
    {
        return $this->profilesAsyncWithHttpInfo($factory_id, $exclude_advanced_services, $expand, $page, $per_page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation profilesAsyncWithHttpInfo
     *
     * Returns a collection of Profile objects.
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  bool $exclude_advanced_services Determine whether exclude Advanced Services profiles from the results. By default this is not set. (optional)
     * @param  bool $expand If expand option is set Profile objects will contain all command parameters, even if their value is default. By default this is not set. (optional)
     * @param  int $page A page to be fetched. Default is &#x60;1&#x60;. (optional)
     * @param  int $per_page A number of results per page. Default is &#x60;100&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function profilesAsyncWithHttpInfo($factory_id, $exclude_advanced_services = null, $expand = null, $page = null, $per_page = null)
    {
        $returnType = '\TelestreamCloudFlip\Model\PaginatedProfilesCollection';
        $request = $this->profilesRequest($factory_id, $exclude_advanced_services, $expand, $page, $per_page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'profiles'
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  bool $exclude_advanced_services Determine whether exclude Advanced Services profiles from the results. By default this is not set. (optional)
     * @param  bool $expand If expand option is set Profile objects will contain all command parameters, even if their value is default. By default this is not set. (optional)
     * @param  int $page A page to be fetched. Default is &#x60;1&#x60;. (optional)
     * @param  int $per_page A number of results per page. Default is &#x60;100&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function profilesRequest($factory_id, $exclude_advanced_services = null, $expand = null, $page = null, $per_page = null)
    {
        // verify the required parameter 'factory_id' is set
        if ($factory_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $factory_id when calling profiles'
            );
        }

        $resourcePath = '/profiles.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($factory_id !== null) {
            $queryParams['factory_id'] = ObjectSerializer::toQueryValue($factory_id);
        }
        // query params
        if ($exclude_advanced_services !== null) {
            $queryParams['exclude_advanced_services'] = ObjectSerializer::toQueryValue($exclude_advanced_services);
        }
        // query params
        if ($expand !== null) {
            $queryParams['expand'] = ObjectSerializer::toQueryValue($expand);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($per_page !== null) {
            $queryParams['per_page'] = ObjectSerializer::toQueryValue($per_page);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queuedVideos
     *
     * Returns a collection of Video objects queued for encoding.
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  int $page A page to be fetched. Default is &#x60;1&#x60;. (optional)
     * @param  int $per_page A number of results per page. Default is &#x60;100&#x60;. (optional)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TelestreamCloudFlip\Model\PaginatedVideoCollection
     */
    public function queuedVideos($factory_id, $page = null, $per_page = null)
    {
        list($response) = $this->queuedVideosWithHttpInfo($factory_id, $page, $per_page);
        return $response;
    }

    /**
     * Operation queuedVideosWithHttpInfo
     *
     * Returns a collection of Video objects queued for encoding.
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  int $page A page to be fetched. Default is &#x60;1&#x60;. (optional)
     * @param  int $per_page A number of results per page. Default is &#x60;100&#x60;. (optional)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TelestreamCloudFlip\Model\PaginatedVideoCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function queuedVideosWithHttpInfo($factory_id, $page = null, $per_page = null)
    {
        $returnType = '\TelestreamCloudFlip\Model\PaginatedVideoCollection';
        $request = $this->queuedVideosRequest($factory_id, $page, $per_page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\PaginatedVideoCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation queuedVideosAsync
     *
     * Returns a collection of Video objects queued for encoding.
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  int $page A page to be fetched. Default is &#x60;1&#x60;. (optional)
     * @param  int $per_page A number of results per page. Default is &#x60;100&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queuedVideosAsync($factory_id, $page = null, $per_page = null)
    {
        return $this->queuedVideosAsyncWithHttpInfo($factory_id, $page, $per_page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queuedVideosAsyncWithHttpInfo
     *
     * Returns a collection of Video objects queued for encoding.
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  int $page A page to be fetched. Default is &#x60;1&#x60;. (optional)
     * @param  int $per_page A number of results per page. Default is &#x60;100&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queuedVideosAsyncWithHttpInfo($factory_id, $page = null, $per_page = null)
    {
        $returnType = '\TelestreamCloudFlip\Model\PaginatedVideoCollection';
        $request = $this->queuedVideosRequest($factory_id, $page, $per_page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queuedVideos'
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  int $page A page to be fetched. Default is &#x60;1&#x60;. (optional)
     * @param  int $per_page A number of results per page. Default is &#x60;100&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function queuedVideosRequest($factory_id, $page = null, $per_page = null)
    {
        // verify the required parameter 'factory_id' is set
        if ($factory_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $factory_id when calling queuedVideos'
            );
        }

        $resourcePath = '/videos/queued.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($factory_id !== null) {
            $queryParams['factory_id'] = ObjectSerializer::toQueryValue($factory_id);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($per_page !== null) {
            $queryParams['per_page'] = ObjectSerializer::toQueryValue($per_page);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation resubmitVideo
     *
     * Resubmits a video to encode.
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\ResubmitVideoBody $resubmit_video_body resubmit_video_body (required)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function resubmitVideo($factory_id, $resubmit_video_body)
    {
        $this->resubmitVideoWithHttpInfo($factory_id, $resubmit_video_body);
    }

    /**
     * Operation resubmitVideoWithHttpInfo
     *
     * Resubmits a video to encode.
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\ResubmitVideoBody $resubmit_video_body (required)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function resubmitVideoWithHttpInfo($factory_id, $resubmit_video_body)
    {
        $returnType = '';
        $request = $this->resubmitVideoRequest($factory_id, $resubmit_video_body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation resubmitVideoAsync
     *
     * Resubmits a video to encode.
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\ResubmitVideoBody $resubmit_video_body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resubmitVideoAsync($factory_id, $resubmit_video_body)
    {
        return $this->resubmitVideoAsyncWithHttpInfo($factory_id, $resubmit_video_body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation resubmitVideoAsyncWithHttpInfo
     *
     * Resubmits a video to encode.
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\ResubmitVideoBody $resubmit_video_body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resubmitVideoAsyncWithHttpInfo($factory_id, $resubmit_video_body)
    {
        $returnType = '';
        $request = $this->resubmitVideoRequest($factory_id, $resubmit_video_body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'resubmitVideo'
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\ResubmitVideoBody $resubmit_video_body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function resubmitVideoRequest($factory_id, $resubmit_video_body)
    {
        // verify the required parameter 'factory_id' is set
        if ($factory_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $factory_id when calling resubmitVideo'
            );
        }
        // verify the required parameter 'resubmit_video_body' is set
        if ($resubmit_video_body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resubmit_video_body when calling resubmitVideo'
            );
        }

        $resourcePath = '/videos/resubmit.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($factory_id !== null) {
            $queryParams['factory_id'] = ObjectSerializer::toQueryValue($factory_id);
        }


        // body params
        $_tempBody = null;
        if (isset($resubmit_video_body)) {
            $_tempBody = $resubmit_video_body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation retryEncoding
     *
     * Retries a failed encoding.
     *
     * @param  string $id Id of an Encoding. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TelestreamCloudFlip\Model\RetriedResponse
     */
    public function retryEncoding($id, $factory_id)
    {
        list($response) = $this->retryEncodingWithHttpInfo($id, $factory_id);
        return $response;
    }

    /**
     * Operation retryEncodingWithHttpInfo
     *
     * Retries a failed encoding.
     *
     * @param  string $id Id of an Encoding. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TelestreamCloudFlip\Model\RetriedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function retryEncodingWithHttpInfo($id, $factory_id)
    {
        $returnType = '\TelestreamCloudFlip\Model\RetriedResponse';
        $request = $this->retryEncodingRequest($id, $factory_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\RetriedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation retryEncodingAsync
     *
     * Retries a failed encoding.
     *
     * @param  string $id Id of an Encoding. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function retryEncodingAsync($id, $factory_id)
    {
        return $this->retryEncodingAsyncWithHttpInfo($id, $factory_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation retryEncodingAsyncWithHttpInfo
     *
     * Retries a failed encoding.
     *
     * @param  string $id Id of an Encoding. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function retryEncodingAsyncWithHttpInfo($id, $factory_id)
    {
        $returnType = '\TelestreamCloudFlip\Model\RetriedResponse';
        $request = $this->retryEncodingRequest($id, $factory_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'retryEncoding'
     *
     * @param  string $id Id of an Encoding. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function retryEncodingRequest($id, $factory_id)
    {
        // verify the required parameter 'id' is set
        if ($id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling retryEncoding'
            );
        }
        // verify the required parameter 'factory_id' is set
        if ($factory_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $factory_id when calling retryEncoding'
            );
        }

        $resourcePath = '/encodings/{id}/retry.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($factory_id !== null) {
            $queryParams['factory_id'] = ObjectSerializer::toQueryValue($factory_id);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation signedEncodingUrl
     *
     * Returns a signed url pointing to an Encoding.
     *
     * @param  string $id Id of an Encoding. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TelestreamCloudFlip\Model\EncodingSignedUrl
     */
    public function signedEncodingUrl($id, $factory_id)
    {
        list($response) = $this->signedEncodingUrlWithHttpInfo($id, $factory_id);
        return $response;
    }

    /**
     * Operation signedEncodingUrlWithHttpInfo
     *
     * Returns a signed url pointing to an Encoding.
     *
     * @param  string $id Id of an Encoding. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TelestreamCloudFlip\Model\EncodingSignedUrl, HTTP status code, HTTP response headers (array of strings)
     */
    public function signedEncodingUrlWithHttpInfo($id, $factory_id)
    {
        $returnType = '\TelestreamCloudFlip\Model\EncodingSignedUrl';
        $request = $this->signedEncodingUrlRequest($id, $factory_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\EncodingSignedUrl',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation signedEncodingUrlAsync
     *
     * Returns a signed url pointing to an Encoding.
     *
     * @param  string $id Id of an Encoding. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function signedEncodingUrlAsync($id, $factory_id)
    {
        return $this->signedEncodingUrlAsyncWithHttpInfo($id, $factory_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation signedEncodingUrlAsyncWithHttpInfo
     *
     * Returns a signed url pointing to an Encoding.
     *
     * @param  string $id Id of an Encoding. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function signedEncodingUrlAsyncWithHttpInfo($id, $factory_id)
    {
        $returnType = '\TelestreamCloudFlip\Model\EncodingSignedUrl';
        $request = $this->signedEncodingUrlRequest($id, $factory_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'signedEncodingUrl'
     *
     * @param  string $id Id of an Encoding. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function signedEncodingUrlRequest($id, $factory_id)
    {
        // verify the required parameter 'id' is set
        if ($id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling signedEncodingUrl'
            );
        }
        // verify the required parameter 'factory_id' is set
        if ($factory_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $factory_id when calling signedEncodingUrl'
            );
        }

        $resourcePath = '/encodings/{id}/signed-url.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($factory_id !== null) {
            $queryParams['factory_id'] = ObjectSerializer::toQueryValue($factory_id);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation signedEncodingUrls
     *
     * Returns a list of signed urls pointing to an Encoding's outputs.
     *
     * @param  string $id Id of an Encoding. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TelestreamCloudFlip\Model\EncodingSignedUrls
     */
    public function signedEncodingUrls($id, $factory_id)
    {
        list($response) = $this->signedEncodingUrlsWithHttpInfo($id, $factory_id);
        return $response;
    }

    /**
     * Operation signedEncodingUrlsWithHttpInfo
     *
     * Returns a list of signed urls pointing to an Encoding's outputs.
     *
     * @param  string $id Id of an Encoding. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TelestreamCloudFlip\Model\EncodingSignedUrls, HTTP status code, HTTP response headers (array of strings)
     */
    public function signedEncodingUrlsWithHttpInfo($id, $factory_id)
    {
        $returnType = '\TelestreamCloudFlip\Model\EncodingSignedUrls';
        $request = $this->signedEncodingUrlsRequest($id, $factory_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\EncodingSignedUrls',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation signedEncodingUrlsAsync
     *
     * Returns a list of signed urls pointing to an Encoding's outputs.
     *
     * @param  string $id Id of an Encoding. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function signedEncodingUrlsAsync($id, $factory_id)
    {
        return $this->signedEncodingUrlsAsyncWithHttpInfo($id, $factory_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation signedEncodingUrlsAsyncWithHttpInfo
     *
     * Returns a list of signed urls pointing to an Encoding's outputs.
     *
     * @param  string $id Id of an Encoding. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function signedEncodingUrlsAsyncWithHttpInfo($id, $factory_id)
    {
        $returnType = '\TelestreamCloudFlip\Model\EncodingSignedUrls';
        $request = $this->signedEncodingUrlsRequest($id, $factory_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'signedEncodingUrls'
     *
     * @param  string $id Id of an Encoding. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function signedEncodingUrlsRequest($id, $factory_id)
    {
        // verify the required parameter 'id' is set
        if ($id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling signedEncodingUrls'
            );
        }
        // verify the required parameter 'factory_id' is set
        if ($factory_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $factory_id when calling signedEncodingUrls'
            );
        }

        $resourcePath = '/encodings/{id}/signed-urls.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($factory_id !== null) {
            $queryParams['factory_id'] = ObjectSerializer::toQueryValue($factory_id);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation signedVideoUrl
     *
     * Returns a signed url pointing to a Video.
     *
     * @param  string $id Id of a Video. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TelestreamCloudFlip\Model\SignedVideoUrl
     */
    public function signedVideoUrl($id, $factory_id)
    {
        list($response) = $this->signedVideoUrlWithHttpInfo($id, $factory_id);
        return $response;
    }

    /**
     * Operation signedVideoUrlWithHttpInfo
     *
     * Returns a signed url pointing to a Video.
     *
     * @param  string $id Id of a Video. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TelestreamCloudFlip\Model\SignedVideoUrl, HTTP status code, HTTP response headers (array of strings)
     */
    public function signedVideoUrlWithHttpInfo($id, $factory_id)
    {
        $returnType = '\TelestreamCloudFlip\Model\SignedVideoUrl';
        $request = $this->signedVideoUrlRequest($id, $factory_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\SignedVideoUrl',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation signedVideoUrlAsync
     *
     * Returns a signed url pointing to a Video.
     *
     * @param  string $id Id of a Video. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function signedVideoUrlAsync($id, $factory_id)
    {
        return $this->signedVideoUrlAsyncWithHttpInfo($id, $factory_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation signedVideoUrlAsyncWithHttpInfo
     *
     * Returns a signed url pointing to a Video.
     *
     * @param  string $id Id of a Video. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function signedVideoUrlAsyncWithHttpInfo($id, $factory_id)
    {
        $returnType = '\TelestreamCloudFlip\Model\SignedVideoUrl';
        $request = $this->signedVideoUrlRequest($id, $factory_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'signedVideoUrl'
     *
     * @param  string $id Id of a Video. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function signedVideoUrlRequest($id, $factory_id)
    {
        // verify the required parameter 'id' is set
        if ($id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling signedVideoUrl'
            );
        }
        // verify the required parameter 'factory_id' is set
        if ($factory_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $factory_id when calling signedVideoUrl'
            );
        }

        $resourcePath = '/videos/{id}/signed-url.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($factory_id !== null) {
            $queryParams['factory_id'] = ObjectSerializer::toQueryValue($factory_id);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation toggleFactorySync
     *
     * Toggles synchronisation settings.
     *
     * @param  string $id id of the factory (required)
     * @param  \TelestreamCloudFlip\Model\FactorySyncBody $factory_sync_body factory_sync_body (required)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TelestreamCloudFlip\Model\FactorySync
     */
    public function toggleFactorySync($id, $factory_sync_body)
    {
        list($response) = $this->toggleFactorySyncWithHttpInfo($id, $factory_sync_body);
        return $response;
    }

    /**
     * Operation toggleFactorySyncWithHttpInfo
     *
     * Toggles synchronisation settings.
     *
     * @param  string $id id of the factory (required)
     * @param  \TelestreamCloudFlip\Model\FactorySyncBody $factory_sync_body (required)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TelestreamCloudFlip\Model\FactorySync, HTTP status code, HTTP response headers (array of strings)
     */
    public function toggleFactorySyncWithHttpInfo($id, $factory_sync_body)
    {
        $returnType = '\TelestreamCloudFlip\Model\FactorySync';
        $request = $this->toggleFactorySyncRequest($id, $factory_sync_body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\FactorySync',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation toggleFactorySyncAsync
     *
     * Toggles synchronisation settings.
     *
     * @param  string $id id of the factory (required)
     * @param  \TelestreamCloudFlip\Model\FactorySyncBody $factory_sync_body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toggleFactorySyncAsync($id, $factory_sync_body)
    {
        return $this->toggleFactorySyncAsyncWithHttpInfo($id, $factory_sync_body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation toggleFactorySyncAsyncWithHttpInfo
     *
     * Toggles synchronisation settings.
     *
     * @param  string $id id of the factory (required)
     * @param  \TelestreamCloudFlip\Model\FactorySyncBody $factory_sync_body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toggleFactorySyncAsyncWithHttpInfo($id, $factory_sync_body)
    {
        $returnType = '\TelestreamCloudFlip\Model\FactorySync';
        $request = $this->toggleFactorySyncRequest($id, $factory_sync_body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'toggleFactorySync'
     *
     * @param  string $id id of the factory (required)
     * @param  \TelestreamCloudFlip\Model\FactorySyncBody $factory_sync_body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function toggleFactorySyncRequest($id, $factory_sync_body)
    {
        // verify the required parameter 'id' is set
        if ($id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling toggleFactorySync'
            );
        }
        // verify the required parameter 'factory_sync_body' is set
        if ($factory_sync_body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $factory_sync_body when calling toggleFactorySync'
            );
        }

        $resourcePath = '/factories/{id}/sync.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($factory_sync_body)) {
            $_tempBody = $factory_sync_body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateEncoding
     *
     * Updates an Encoding
     *
     * @param  string $id Id of an Encoding. (required)
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\UpdateEncodingBody $update_encoding_body update_encoding_body (required)
     * @param  bool $screenshots Determines whether the response will include screenshots. By default this is not set. (optional)
     * @param  bool $precise_status Determines whether the response will include a precise status. By default this is not set. (optional)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TelestreamCloudFlip\Model\Encoding
     */
    public function updateEncoding($id, $factory_id, $update_encoding_body, $screenshots = null, $precise_status = null)
    {
        list($response) = $this->updateEncodingWithHttpInfo($id, $factory_id, $update_encoding_body, $screenshots, $precise_status);
        return $response;
    }

    /**
     * Operation updateEncodingWithHttpInfo
     *
     * Updates an Encoding
     *
     * @param  string $id Id of an Encoding. (required)
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\UpdateEncodingBody $update_encoding_body (required)
     * @param  bool $screenshots Determines whether the response will include screenshots. By default this is not set. (optional)
     * @param  bool $precise_status Determines whether the response will include a precise status. By default this is not set. (optional)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TelestreamCloudFlip\Model\Encoding, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateEncodingWithHttpInfo($id, $factory_id, $update_encoding_body, $screenshots = null, $precise_status = null)
    {
        $returnType = '\TelestreamCloudFlip\Model\Encoding';
        $request = $this->updateEncodingRequest($id, $factory_id, $update_encoding_body, $screenshots, $precise_status);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Encoding',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateEncodingAsync
     *
     * Updates an Encoding
     *
     * @param  string $id Id of an Encoding. (required)
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\UpdateEncodingBody $update_encoding_body (required)
     * @param  bool $screenshots Determines whether the response will include screenshots. By default this is not set. (optional)
     * @param  bool $precise_status Determines whether the response will include a precise status. By default this is not set. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateEncodingAsync($id, $factory_id, $update_encoding_body, $screenshots = null, $precise_status = null)
    {
        return $this->updateEncodingAsyncWithHttpInfo($id, $factory_id, $update_encoding_body, $screenshots, $precise_status)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateEncodingAsyncWithHttpInfo
     *
     * Updates an Encoding
     *
     * @param  string $id Id of an Encoding. (required)
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\UpdateEncodingBody $update_encoding_body (required)
     * @param  bool $screenshots Determines whether the response will include screenshots. By default this is not set. (optional)
     * @param  bool $precise_status Determines whether the response will include a precise status. By default this is not set. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateEncodingAsyncWithHttpInfo($id, $factory_id, $update_encoding_body, $screenshots = null, $precise_status = null)
    {
        $returnType = '\TelestreamCloudFlip\Model\Encoding';
        $request = $this->updateEncodingRequest($id, $factory_id, $update_encoding_body, $screenshots, $precise_status);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateEncoding'
     *
     * @param  string $id Id of an Encoding. (required)
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\UpdateEncodingBody $update_encoding_body (required)
     * @param  bool $screenshots Determines whether the response will include screenshots. By default this is not set. (optional)
     * @param  bool $precise_status Determines whether the response will include a precise status. By default this is not set. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateEncodingRequest($id, $factory_id, $update_encoding_body, $screenshots = null, $precise_status = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateEncoding'
            );
        }
        // verify the required parameter 'factory_id' is set
        if ($factory_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $factory_id when calling updateEncoding'
            );
        }
        // verify the required parameter 'update_encoding_body' is set
        if ($update_encoding_body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_encoding_body when calling updateEncoding'
            );
        }

        $resourcePath = '/encodings/{id}.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($factory_id !== null) {
            $queryParams['factory_id'] = ObjectSerializer::toQueryValue($factory_id);
        }
        // query params
        if ($screenshots !== null) {
            $queryParams['screenshots'] = ObjectSerializer::toQueryValue($screenshots);
        }
        // query params
        if ($precise_status !== null) {
            $queryParams['precise_status'] = ObjectSerializer::toQueryValue($precise_status);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($update_encoding_body)) {
            $_tempBody = $update_encoding_body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateFactory
     *
     * Updates a Factory's settings. Returns a Factory object.
     *
     * @param  string $id id of the factory (required)
     * @param  \TelestreamCloudFlip\Model\FactoryBody $update_factory_body update_factory_body (required)
     * @param  bool $with_storage_provider if set to &#x60;true&#x60;, results will include a storage provider&#39;s id (optional)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TelestreamCloudFlip\Model\Factory
     */
    public function updateFactory($id, $update_factory_body, $with_storage_provider = null)
    {
        list($response) = $this->updateFactoryWithHttpInfo($id, $update_factory_body, $with_storage_provider);
        return $response;
    }

    /**
     * Operation updateFactoryWithHttpInfo
     *
     * Updates a Factory's settings. Returns a Factory object.
     *
     * @param  string $id id of the factory (required)
     * @param  \TelestreamCloudFlip\Model\FactoryBody $update_factory_body (required)
     * @param  bool $with_storage_provider if set to &#x60;true&#x60;, results will include a storage provider&#39;s id (optional)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TelestreamCloudFlip\Model\Factory, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateFactoryWithHttpInfo($id, $update_factory_body, $with_storage_provider = null)
    {
        $returnType = '\TelestreamCloudFlip\Model\Factory';
        $request = $this->updateFactoryRequest($id, $update_factory_body, $with_storage_provider);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Factory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateFactoryAsync
     *
     * Updates a Factory's settings. Returns a Factory object.
     *
     * @param  string $id id of the factory (required)
     * @param  \TelestreamCloudFlip\Model\FactoryBody $update_factory_body (required)
     * @param  bool $with_storage_provider if set to &#x60;true&#x60;, results will include a storage provider&#39;s id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateFactoryAsync($id, $update_factory_body, $with_storage_provider = null)
    {
        return $this->updateFactoryAsyncWithHttpInfo($id, $update_factory_body, $with_storage_provider)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateFactoryAsyncWithHttpInfo
     *
     * Updates a Factory's settings. Returns a Factory object.
     *
     * @param  string $id id of the factory (required)
     * @param  \TelestreamCloudFlip\Model\FactoryBody $update_factory_body (required)
     * @param  bool $with_storage_provider if set to &#x60;true&#x60;, results will include a storage provider&#39;s id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateFactoryAsyncWithHttpInfo($id, $update_factory_body, $with_storage_provider = null)
    {
        $returnType = '\TelestreamCloudFlip\Model\Factory';
        $request = $this->updateFactoryRequest($id, $update_factory_body, $with_storage_provider);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateFactory'
     *
     * @param  string $id id of the factory (required)
     * @param  \TelestreamCloudFlip\Model\FactoryBody $update_factory_body (required)
     * @param  bool $with_storage_provider if set to &#x60;true&#x60;, results will include a storage provider&#39;s id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateFactoryRequest($id, $update_factory_body, $with_storage_provider = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateFactory'
            );
        }
        // verify the required parameter 'update_factory_body' is set
        if ($update_factory_body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_factory_body when calling updateFactory'
            );
        }

        $resourcePath = '/factories/{id}.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($with_storage_provider !== null) {
            $queryParams['with_storage_provider'] = ObjectSerializer::toQueryValue($with_storage_provider);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($update_factory_body)) {
            $_tempBody = $update_factory_body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNotifications
     *
     * Updates a Factory's notification settings.
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\CloudNotificationSettings $cloud_notification_settings_body cloud_notification_settings_body (required)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TelestreamCloudFlip\Model\CloudNotificationSettings
     */
    public function updateNotifications($factory_id, $cloud_notification_settings_body)
    {
        list($response) = $this->updateNotificationsWithHttpInfo($factory_id, $cloud_notification_settings_body);
        return $response;
    }

    /**
     * Operation updateNotificationsWithHttpInfo
     *
     * Updates a Factory's notification settings.
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\CloudNotificationSettings $cloud_notification_settings_body (required)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TelestreamCloudFlip\Model\CloudNotificationSettings, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNotificationsWithHttpInfo($factory_id, $cloud_notification_settings_body)
    {
        $returnType = '\TelestreamCloudFlip\Model\CloudNotificationSettings';
        $request = $this->updateNotificationsRequest($factory_id, $cloud_notification_settings_body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\CloudNotificationSettings',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNotificationsAsync
     *
     * Updates a Factory's notification settings.
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\CloudNotificationSettings $cloud_notification_settings_body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNotificationsAsync($factory_id, $cloud_notification_settings_body)
    {
        return $this->updateNotificationsAsyncWithHttpInfo($factory_id, $cloud_notification_settings_body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNotificationsAsyncWithHttpInfo
     *
     * Updates a Factory's notification settings.
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\CloudNotificationSettings $cloud_notification_settings_body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNotificationsAsyncWithHttpInfo($factory_id, $cloud_notification_settings_body)
    {
        $returnType = '\TelestreamCloudFlip\Model\CloudNotificationSettings';
        $request = $this->updateNotificationsRequest($factory_id, $cloud_notification_settings_body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNotifications'
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\CloudNotificationSettings $cloud_notification_settings_body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateNotificationsRequest($factory_id, $cloud_notification_settings_body)
    {
        // verify the required parameter 'factory_id' is set
        if ($factory_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $factory_id when calling updateNotifications'
            );
        }
        // verify the required parameter 'cloud_notification_settings_body' is set
        if ($cloud_notification_settings_body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cloud_notification_settings_body when calling updateNotifications'
            );
        }

        $resourcePath = '/notifications.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($factory_id !== null) {
            $queryParams['factory_id'] = ObjectSerializer::toQueryValue($factory_id);
        }


        // body params
        $_tempBody = null;
        if (isset($cloud_notification_settings_body)) {
            $_tempBody = $cloud_notification_settings_body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateProfile
     *
     * Updates a given Profile
     *
     * @param  string $id id (required)
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\ProfileBody $update_profile_body update_profile_body (required)
     * @param  bool $exclude_advanced_services exclude_advanced_services (optional)
     * @param  bool $expand If expand option is set Profile objects will contain all command parameters, even if their value is default. By default this is not set. (optional)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TelestreamCloudFlip\Model\Profile
     */
    public function updateProfile($id, $factory_id, $update_profile_body, $exclude_advanced_services = null, $expand = null)
    {
        list($response) = $this->updateProfileWithHttpInfo($id, $factory_id, $update_profile_body, $exclude_advanced_services, $expand);
        return $response;
    }

    /**
     * Operation updateProfileWithHttpInfo
     *
     * Updates a given Profile
     *
     * @param  string $id (required)
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\ProfileBody $update_profile_body (required)
     * @param  bool $exclude_advanced_services (optional)
     * @param  bool $expand If expand option is set Profile objects will contain all command parameters, even if their value is default. By default this is not set. (optional)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TelestreamCloudFlip\Model\Profile, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateProfileWithHttpInfo($id, $factory_id, $update_profile_body, $exclude_advanced_services = null, $expand = null)
    {
        $returnType = '\TelestreamCloudFlip\Model\Profile';
        $request = $this->updateProfileRequest($id, $factory_id, $update_profile_body, $exclude_advanced_services, $expand);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Profile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateProfileAsync
     *
     * Updates a given Profile
     *
     * @param  string $id (required)
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\ProfileBody $update_profile_body (required)
     * @param  bool $exclude_advanced_services (optional)
     * @param  bool $expand If expand option is set Profile objects will contain all command parameters, even if their value is default. By default this is not set. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateProfileAsync($id, $factory_id, $update_profile_body, $exclude_advanced_services = null, $expand = null)
    {
        return $this->updateProfileAsyncWithHttpInfo($id, $factory_id, $update_profile_body, $exclude_advanced_services, $expand)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateProfileAsyncWithHttpInfo
     *
     * Updates a given Profile
     *
     * @param  string $id (required)
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\ProfileBody $update_profile_body (required)
     * @param  bool $exclude_advanced_services (optional)
     * @param  bool $expand If expand option is set Profile objects will contain all command parameters, even if their value is default. By default this is not set. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateProfileAsyncWithHttpInfo($id, $factory_id, $update_profile_body, $exclude_advanced_services = null, $expand = null)
    {
        $returnType = '\TelestreamCloudFlip\Model\Profile';
        $request = $this->updateProfileRequest($id, $factory_id, $update_profile_body, $exclude_advanced_services, $expand);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateProfile'
     *
     * @param  string $id (required)
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\ProfileBody $update_profile_body (required)
     * @param  bool $exclude_advanced_services (optional)
     * @param  bool $expand If expand option is set Profile objects will contain all command parameters, even if their value is default. By default this is not set. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateProfileRequest($id, $factory_id, $update_profile_body, $exclude_advanced_services = null, $expand = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateProfile'
            );
        }
        // verify the required parameter 'factory_id' is set
        if ($factory_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $factory_id when calling updateProfile'
            );
        }
        // verify the required parameter 'update_profile_body' is set
        if ($update_profile_body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_profile_body when calling updateProfile'
            );
        }

        $resourcePath = '/profiles/{id}.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($factory_id !== null) {
            $queryParams['factory_id'] = ObjectSerializer::toQueryValue($factory_id);
        }
        // query params
        if ($exclude_advanced_services !== null) {
            $queryParams['exclude_advanced_services'] = ObjectSerializer::toQueryValue($exclude_advanced_services);
        }
        // query params
        if ($expand !== null) {
            $queryParams['expand'] = ObjectSerializer::toQueryValue($expand);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($update_profile_body)) {
            $_tempBody = $update_profile_body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation uploadVideo
     *
     * Creates an upload session.
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\VideoUploadBody $video_upload_body video_upload_body (required)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TelestreamCloudFlip\Model\UploadSession
     */
    public function uploadVideo($factory_id, $video_upload_body)
    {
        list($response) = $this->uploadVideoWithHttpInfo($factory_id, $video_upload_body);
        return $response;
    }

    /**
     * Operation uploadVideoWithHttpInfo
     *
     * Creates an upload session.
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\VideoUploadBody $video_upload_body (required)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TelestreamCloudFlip\Model\UploadSession, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadVideoWithHttpInfo($factory_id, $video_upload_body)
    {
        $returnType = '\TelestreamCloudFlip\Model\UploadSession';
        $request = $this->uploadVideoRequest($factory_id, $video_upload_body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\UploadSession',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation uploadVideoAsync
     *
     * Creates an upload session.
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\VideoUploadBody $video_upload_body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadVideoAsync($factory_id, $video_upload_body)
    {
        return $this->uploadVideoAsyncWithHttpInfo($factory_id, $video_upload_body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadVideoAsyncWithHttpInfo
     *
     * Creates an upload session.
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\VideoUploadBody $video_upload_body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadVideoAsyncWithHttpInfo($factory_id, $video_upload_body)
    {
        $returnType = '\TelestreamCloudFlip\Model\UploadSession';
        $request = $this->uploadVideoRequest($factory_id, $video_upload_body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uploadVideo'
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  \TelestreamCloudFlip\Model\VideoUploadBody $video_upload_body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function uploadVideoRequest($factory_id, $video_upload_body)
    {
        // verify the required parameter 'factory_id' is set
        if ($factory_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $factory_id when calling uploadVideo'
            );
        }
        // verify the required parameter 'video_upload_body' is set
        if ($video_upload_body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $video_upload_body when calling uploadVideo'
            );
        }

        $resourcePath = '/videos/upload.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($factory_id !== null) {
            $queryParams['factory_id'] = ObjectSerializer::toQueryValue($factory_id);
        }


        // body params
        $_tempBody = null;
        if (isset($video_upload_body)) {
            $_tempBody = $video_upload_body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation video
     *
     * Returns a Video object.
     *
     * @param  string $id Id of a Video. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TelestreamCloudFlip\Model\Video
     */
    public function video($id, $factory_id)
    {
        list($response) = $this->videoWithHttpInfo($id, $factory_id);
        return $response;
    }

    /**
     * Operation videoWithHttpInfo
     *
     * Returns a Video object.
     *
     * @param  string $id Id of a Video. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TelestreamCloudFlip\Model\Video, HTTP status code, HTTP response headers (array of strings)
     */
    public function videoWithHttpInfo($id, $factory_id)
    {
        $returnType = '\TelestreamCloudFlip\Model\Video';
        $request = $this->videoRequest($id, $factory_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Video',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation videoAsync
     *
     * Returns a Video object.
     *
     * @param  string $id Id of a Video. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function videoAsync($id, $factory_id)
    {
        return $this->videoAsyncWithHttpInfo($id, $factory_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation videoAsyncWithHttpInfo
     *
     * Returns a Video object.
     *
     * @param  string $id Id of a Video. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function videoAsyncWithHttpInfo($id, $factory_id)
    {
        $returnType = '\TelestreamCloudFlip\Model\Video';
        $request = $this->videoRequest($id, $factory_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'video'
     *
     * @param  string $id Id of a Video. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function videoRequest($id, $factory_id)
    {
        // verify the required parameter 'id' is set
        if ($id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling video'
            );
        }
        // verify the required parameter 'factory_id' is set
        if ($factory_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $factory_id when calling video'
            );
        }

        $resourcePath = '/videos/{id}.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($factory_id !== null) {
            $queryParams['factory_id'] = ObjectSerializer::toQueryValue($factory_id);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation videoEncodings
     *
     * Returns a list of Encodings that belong to a Video.
     *
     * @param  string $id Id of a Video. (required)
     * @param  string $factory_id Id of a Factory. (required)
     * @param  int $page A page to be fetched. Default is &#x60;1&#x60;. (optional)
     * @param  int $per_page A number of results per page. Default is &#x60;100&#x60;. (optional)
     * @param  bool $screenshots Determines whether the response will include screenshots. By default this is not set. (optional)
     * @param  bool $precise_status Determines whether the response will include a precise status. By default this is not set. (optional)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TelestreamCloudFlip\Model\PaginatedEncodingsCollection
     */
    public function videoEncodings($id, $factory_id, $page = null, $per_page = null, $screenshots = null, $precise_status = null)
    {
        list($response) = $this->videoEncodingsWithHttpInfo($id, $factory_id, $page, $per_page, $screenshots, $precise_status);
        return $response;
    }

    /**
     * Operation videoEncodingsWithHttpInfo
     *
     * Returns a list of Encodings that belong to a Video.
     *
     * @param  string $id Id of a Video. (required)
     * @param  string $factory_id Id of a Factory. (required)
     * @param  int $page A page to be fetched. Default is &#x60;1&#x60;. (optional)
     * @param  int $per_page A number of results per page. Default is &#x60;100&#x60;. (optional)
     * @param  bool $screenshots Determines whether the response will include screenshots. By default this is not set. (optional)
     * @param  bool $precise_status Determines whether the response will include a precise status. By default this is not set. (optional)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TelestreamCloudFlip\Model\PaginatedEncodingsCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function videoEncodingsWithHttpInfo($id, $factory_id, $page = null, $per_page = null, $screenshots = null, $precise_status = null)
    {
        $returnType = '\TelestreamCloudFlip\Model\PaginatedEncodingsCollection';
        $request = $this->videoEncodingsRequest($id, $factory_id, $page, $per_page, $screenshots, $precise_status);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\PaginatedEncodingsCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation videoEncodingsAsync
     *
     * Returns a list of Encodings that belong to a Video.
     *
     * @param  string $id Id of a Video. (required)
     * @param  string $factory_id Id of a Factory. (required)
     * @param  int $page A page to be fetched. Default is &#x60;1&#x60;. (optional)
     * @param  int $per_page A number of results per page. Default is &#x60;100&#x60;. (optional)
     * @param  bool $screenshots Determines whether the response will include screenshots. By default this is not set. (optional)
     * @param  bool $precise_status Determines whether the response will include a precise status. By default this is not set. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function videoEncodingsAsync($id, $factory_id, $page = null, $per_page = null, $screenshots = null, $precise_status = null)
    {
        return $this->videoEncodingsAsyncWithHttpInfo($id, $factory_id, $page, $per_page, $screenshots, $precise_status)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation videoEncodingsAsyncWithHttpInfo
     *
     * Returns a list of Encodings that belong to a Video.
     *
     * @param  string $id Id of a Video. (required)
     * @param  string $factory_id Id of a Factory. (required)
     * @param  int $page A page to be fetched. Default is &#x60;1&#x60;. (optional)
     * @param  int $per_page A number of results per page. Default is &#x60;100&#x60;. (optional)
     * @param  bool $screenshots Determines whether the response will include screenshots. By default this is not set. (optional)
     * @param  bool $precise_status Determines whether the response will include a precise status. By default this is not set. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function videoEncodingsAsyncWithHttpInfo($id, $factory_id, $page = null, $per_page = null, $screenshots = null, $precise_status = null)
    {
        $returnType = '\TelestreamCloudFlip\Model\PaginatedEncodingsCollection';
        $request = $this->videoEncodingsRequest($id, $factory_id, $page, $per_page, $screenshots, $precise_status);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'videoEncodings'
     *
     * @param  string $id Id of a Video. (required)
     * @param  string $factory_id Id of a Factory. (required)
     * @param  int $page A page to be fetched. Default is &#x60;1&#x60;. (optional)
     * @param  int $per_page A number of results per page. Default is &#x60;100&#x60;. (optional)
     * @param  bool $screenshots Determines whether the response will include screenshots. By default this is not set. (optional)
     * @param  bool $precise_status Determines whether the response will include a precise status. By default this is not set. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function videoEncodingsRequest($id, $factory_id, $page = null, $per_page = null, $screenshots = null, $precise_status = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling videoEncodings'
            );
        }
        // verify the required parameter 'factory_id' is set
        if ($factory_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $factory_id when calling videoEncodings'
            );
        }

        $resourcePath = '/videos/{id}/encodings.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($factory_id !== null) {
            $queryParams['factory_id'] = ObjectSerializer::toQueryValue($factory_id);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($per_page !== null) {
            $queryParams['per_page'] = ObjectSerializer::toQueryValue($per_page);
        }
        // query params
        if ($screenshots !== null) {
            $queryParams['screenshots'] = ObjectSerializer::toQueryValue($screenshots);
        }
        // query params
        if ($precise_status !== null) {
            $queryParams['precise_status'] = ObjectSerializer::toQueryValue($precise_status);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation videoMetadata
     *
     * Returns a Video's metadata
     *
     * @param  string $id Id of a Video. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TelestreamCloudFlip\Model\VideoMetadata
     */
    public function videoMetadata($id, $factory_id)
    {
        list($response) = $this->videoMetadataWithHttpInfo($id, $factory_id);
        return $response;
    }

    /**
     * Operation videoMetadataWithHttpInfo
     *
     * Returns a Video's metadata
     *
     * @param  string $id Id of a Video. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TelestreamCloudFlip\Model\VideoMetadata, HTTP status code, HTTP response headers (array of strings)
     */
    public function videoMetadataWithHttpInfo($id, $factory_id)
    {
        $returnType = '\TelestreamCloudFlip\Model\VideoMetadata';
        $request = $this->videoMetadataRequest($id, $factory_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\VideoMetadata',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation videoMetadataAsync
     *
     * Returns a Video's metadata
     *
     * @param  string $id Id of a Video. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function videoMetadataAsync($id, $factory_id)
    {
        return $this->videoMetadataAsyncWithHttpInfo($id, $factory_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation videoMetadataAsyncWithHttpInfo
     *
     * Returns a Video's metadata
     *
     * @param  string $id Id of a Video. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function videoMetadataAsyncWithHttpInfo($id, $factory_id)
    {
        $returnType = '\TelestreamCloudFlip\Model\VideoMetadata';
        $request = $this->videoMetadataRequest($id, $factory_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'videoMetadata'
     *
     * @param  string $id Id of a Video. (required)
     * @param  string $factory_id Id of a Factory. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function videoMetadataRequest($id, $factory_id)
    {
        // verify the required parameter 'id' is set
        if ($id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling videoMetadata'
            );
        }
        // verify the required parameter 'factory_id' is set
        if ($factory_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $factory_id when calling videoMetadata'
            );
        }

        $resourcePath = '/videos/{id}/metadata.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($factory_id !== null) {
            $queryParams['factory_id'] = ObjectSerializer::toQueryValue($factory_id);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation videos
     *
     * Returns a collection of Video objects.
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  int $page A page to be fetched. Default is &#x60;1&#x60;. (optional)
     * @param  int $per_page A number of results per page. Default is &#x60;100&#x60;. (optional)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TelestreamCloudFlip\Model\PaginatedVideoCollection
     */
    public function videos($factory_id, $page = null, $per_page = null)
    {
        list($response) = $this->videosWithHttpInfo($factory_id, $page, $per_page);
        return $response;
    }

    /**
     * Operation videosWithHttpInfo
     *
     * Returns a collection of Video objects.
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  int $page A page to be fetched. Default is &#x60;1&#x60;. (optional)
     * @param  int $per_page A number of results per page. Default is &#x60;100&#x60;. (optional)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TelestreamCloudFlip\Model\PaginatedVideoCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function videosWithHttpInfo($factory_id, $page = null, $per_page = null)
    {
        $returnType = '\TelestreamCloudFlip\Model\PaginatedVideoCollection';
        $request = $this->videosRequest($factory_id, $page, $per_page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\PaginatedVideoCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation videosAsync
     *
     * Returns a collection of Video objects.
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  int $page A page to be fetched. Default is &#x60;1&#x60;. (optional)
     * @param  int $per_page A number of results per page. Default is &#x60;100&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function videosAsync($factory_id, $page = null, $per_page = null)
    {
        return $this->videosAsyncWithHttpInfo($factory_id, $page, $per_page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation videosAsyncWithHttpInfo
     *
     * Returns a collection of Video objects.
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  int $page A page to be fetched. Default is &#x60;1&#x60;. (optional)
     * @param  int $per_page A number of results per page. Default is &#x60;100&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function videosAsyncWithHttpInfo($factory_id, $page = null, $per_page = null)
    {
        $returnType = '\TelestreamCloudFlip\Model\PaginatedVideoCollection';
        $request = $this->videosRequest($factory_id, $page, $per_page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'videos'
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  int $page A page to be fetched. Default is &#x60;1&#x60;. (optional)
     * @param  int $per_page A number of results per page. Default is &#x60;100&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function videosRequest($factory_id, $page = null, $per_page = null)
    {
        // verify the required parameter 'factory_id' is set
        if ($factory_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $factory_id when calling videos'
            );
        }

        $resourcePath = '/videos.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($factory_id !== null) {
            $queryParams['factory_id'] = ObjectSerializer::toQueryValue($factory_id);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($per_page !== null) {
            $queryParams['per_page'] = ObjectSerializer::toQueryValue($per_page);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation workflows
     *
     * Returns a collection of Workflows that belong to a Factory.
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  int $page A page to be fetched. Default is &#x60;1&#x60;. (optional)
     * @param  int $per_page A number of results per page. Default is &#x60;100&#x60;. (optional)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TelestreamCloudFlip\Model\PaginatedWorkflowsCollection
     */
    public function workflows($factory_id, $page = null, $per_page = null)
    {
        list($response) = $this->workflowsWithHttpInfo($factory_id, $page, $per_page);
        return $response;
    }

    /**
     * Operation workflowsWithHttpInfo
     *
     * Returns a collection of Workflows that belong to a Factory.
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  int $page A page to be fetched. Default is &#x60;1&#x60;. (optional)
     * @param  int $per_page A number of results per page. Default is &#x60;100&#x60;. (optional)
     *
     * @throws \TelestreamCloudFlip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TelestreamCloudFlip\Model\PaginatedWorkflowsCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function workflowsWithHttpInfo($factory_id, $page = null, $per_page = null)
    {
        $returnType = '\TelestreamCloudFlip\Model\PaginatedWorkflowsCollection';
        $request = $this->workflowsRequest($factory_id, $page, $per_page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\PaginatedWorkflowsCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TelestreamCloudFlip\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation workflowsAsync
     *
     * Returns a collection of Workflows that belong to a Factory.
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  int $page A page to be fetched. Default is &#x60;1&#x60;. (optional)
     * @param  int $per_page A number of results per page. Default is &#x60;100&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function workflowsAsync($factory_id, $page = null, $per_page = null)
    {
        return $this->workflowsAsyncWithHttpInfo($factory_id, $page, $per_page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation workflowsAsyncWithHttpInfo
     *
     * Returns a collection of Workflows that belong to a Factory.
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  int $page A page to be fetched. Default is &#x60;1&#x60;. (optional)
     * @param  int $per_page A number of results per page. Default is &#x60;100&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function workflowsAsyncWithHttpInfo($factory_id, $page = null, $per_page = null)
    {
        $returnType = '\TelestreamCloudFlip\Model\PaginatedWorkflowsCollection';
        $request = $this->workflowsRequest($factory_id, $page, $per_page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'workflows'
     *
     * @param  string $factory_id Id of a Factory. (required)
     * @param  int $page A page to be fetched. Default is &#x60;1&#x60;. (optional)
     * @param  int $per_page A number of results per page. Default is &#x60;100&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function workflowsRequest($factory_id, $page = null, $per_page = null)
    {
        // verify the required parameter 'factory_id' is set
        if ($factory_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $factory_id when calling workflows'
            );
        }

        $resourcePath = '/workflows.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($factory_id !== null) {
            $queryParams['factory_id'] = ObjectSerializer::toQueryValue($factory_id);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($per_page !== null) {
            $queryParams['per_page'] = ObjectSerializer::toQueryValue($per_page);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = Utils::jsonEncode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
